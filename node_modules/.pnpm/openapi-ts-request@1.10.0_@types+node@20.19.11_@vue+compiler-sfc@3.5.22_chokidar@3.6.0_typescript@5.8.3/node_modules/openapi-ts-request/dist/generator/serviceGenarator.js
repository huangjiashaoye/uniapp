"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const glob_1 = require("glob");
const lodash_1 = require("lodash");
const minimatch_1 = require("minimatch");
const nunjucks_1 = tslib_1.__importDefault(require("nunjucks"));
const path_1 = require("path");
const rimraf_1 = require("rimraf");
const config_1 = require("../config");
const log_1 = tslib_1.__importDefault(require("../log"));
const util_1 = require("../util");
const config_2 = require("./config");
const file_1 = require("./file");
const merge_1 = require("./merge");
const patchSchema_1 = require("./patchSchema");
const util_2 = require("./util");
class ServiceGenerator {
    constructor(config, openAPIData) {
        var _a, _b, _c, _d, _e;
        this.apiData = {};
        this.classNameList = [];
        this.schemaList = [];
        this.interfaceTPConfigs = [];
        this.config = Object.assign({ templatesFolder: (0, path_1.join)(__dirname, '../../', 'templates') }, config);
        this.generateInfoLog();
        const includeTags = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.includeTags) || [];
        const includePaths = ((_b = this.config) === null || _b === void 0 ? void 0 : _b.includePaths) || [];
        const excludeTags = ((_c = this.config) === null || _c === void 0 ? void 0 : _c.excludeTags) || [];
        const excludePaths = ((_d = this.config) === null || _d === void 0 ? void 0 : _d.excludePaths) || [];
        const priorityRule = config_1.PriorityRule[config.priorityRule];
        if ((_e = this.config.hook) === null || _e === void 0 ? void 0 : _e.afterOpenApiDataInited) {
            this.openAPIData =
                this.config.hook.afterOpenApiDataInited(openAPIData) || openAPIData;
        }
        else {
            this.openAPIData = openAPIData;
        }
        // ç”¨ tag åˆ†ç»„ paths, { [tag]: [pathMap, pathMap] }
        outerLoop: for (const pathKey in this.openAPIData.paths) {
            // è¿™é‡Œåˆ¤æ–­paths
            switch (priorityRule) {
                case config_1.PriorityRule.include: {
                    // includePaths and includeTags is empty, ç›´æŽ¥è·³è¿‡
                    if ((0, lodash_1.isEmpty)(includeTags) && (0, lodash_1.isEmpty)(includePaths)) {
                        this.log('priorityRule include need includeTags or includePaths');
                        break outerLoop;
                    }
                    if (!(0, lodash_1.isEmpty)(includePaths) &&
                        !this.validateRegexp(pathKey, includePaths)) {
                        continue;
                    }
                    break;
                }
                case config_1.PriorityRule.exclude: {
                    if (this.validateRegexp(pathKey, excludePaths)) {
                        continue;
                    }
                    break;
                }
                case config_1.PriorityRule.both: {
                    // includePaths and includeTags is emptyï¼Œç›´æŽ¥è·³è¿‡
                    if ((0, lodash_1.isEmpty)(includeTags) && (0, lodash_1.isEmpty)(includePaths)) {
                        this.log('priorityRule both need includeTags or includePaths');
                        break outerLoop;
                    }
                    const outIncludePaths = !(0, lodash_1.isEmpty)(includePaths) &&
                        !this.validateRegexp(pathKey, includePaths);
                    const inExcludePaths = !(0, lodash_1.isEmpty)(excludePaths) &&
                        this.validateRegexp(pathKey, excludePaths);
                    if (outIncludePaths || inExcludePaths) {
                        continue;
                    }
                    break;
                }
                default:
                    throw new Error('priorityRule must be "include" or "exclude" or "include"');
            }
            const pathItem = this.openAPIData.paths[pathKey];
            (0, lodash_1.forEach)(config_2.methods, (method) => {
                var _a;
                const operationObject = pathItem[method];
                if (!operationObject) {
                    return;
                }
                const hookCustomFileNames = ((_a = this.config.hook) === null || _a === void 0 ? void 0 : _a.customFileNames) || util_2.getDefaultFileTag;
                const tags = hookCustomFileNames(operationObject, pathKey, method);
                // è¿™é‡Œåˆ¤æ–­tags
                tags.forEach((tag) => {
                    if (!tag) {
                        return;
                    }
                    if (priorityRule === config_1.PriorityRule.include) {
                        // includeTags ä¸ºç©ºï¼Œä¸ä¼šåŒ¹é…ä»»ä½•pathï¼Œæ•…è·³è¿‡
                        if ((0, lodash_1.isEmpty)(includeTags)) {
                            this.log('priorityRule include need includeTags or includePaths');
                            return;
                        }
                        if (!this.validateRegexp(tag, includeTags)) {
                            return;
                        }
                    }
                    if (priorityRule === config_1.PriorityRule.exclude) {
                        if (this.validateRegexp(tag, excludeTags)) {
                            return;
                        }
                    }
                    if (priorityRule === config_1.PriorityRule.both) {
                        // includeTags is empty æ²¡æœ‰é…ç½®, ç›´æŽ¥è·³è¿‡
                        if ((0, lodash_1.isEmpty)(includeTags)) {
                            this.log('priorityRule both need includeTags or includePaths');
                            return;
                        }
                        const outIncludeTags = !(0, lodash_1.isEmpty)(includeTags) && !this.validateRegexp(tag, includeTags);
                        const inExcludeTags = !(0, lodash_1.isEmpty)(excludeTags) && this.validateRegexp(tag, excludeTags);
                        if (outIncludeTags || inExcludeTags) {
                            return;
                        }
                    }
                    const tagTypeName = (0, util_2.resolveTypeName)(tag);
                    const tagKey = this.config.isCamelCase
                        ? (0, util_1.camelCase)(tagTypeName)
                        : (0, lodash_1.lowerFirst)(tagTypeName);
                    if (!this.apiData[tagKey]) {
                        this.apiData[tagKey] = [];
                    }
                    this.apiData[tagKey].push(Object.assign({ path: pathKey, method }, operationObject));
                });
            });
        }
    }
    genFile() {
        var _a, _b, _c, _d;
        if (this.config.full) {
            try {
                (0, glob_1.globSync)(`${this.config.serversPath}/**/*`)
                    .filter((item) => !item.includes('_deperated'))
                    .forEach((item) => {
                    (0, rimraf_1.rimrafSync)(item);
                });
            }
            catch (error) {
                (0, log_1.default)(`ðŸš¥ api ç”Ÿæˆå¤±è´¥: ${error}`);
            }
        }
        const isOnlyGenTypeScriptType = this.config.isOnlyGenTypeScriptType;
        const isGenJavaScript = this.config.isGenJavaScript;
        const reactQueryMode = this.config.reactQueryMode;
        const reactQueryFileName = (0, config_2.displayReactQueryFileName)(reactQueryMode);
        if (!isOnlyGenTypeScriptType) {
            const prettierError = [];
            // ç”Ÿæˆ service controller æ–‡ä»¶
            this.getServiceTPConfigs().forEach((tp) => {
                var _a, _b;
                const { list } = tp, restTp = tslib_1.__rest(tp, ["list"]);
                const payload = Object.assign({ namespace: this.config.namespace, requestOptionsType: this.config.requestOptionsType, requestImportStatement: this.config.requestImportStatement, interfaceFileName: config_2.interfaceFileName, list }, restTp);
                const hookCustomTemplateService = (_b = (_a = this.config.hook) === null || _a === void 0 ? void 0 : _a.customTemplates) === null || _b === void 0 ? void 0 : _b[config_2.TypescriptFileType.serviceController];
                if (hookCustomTemplateService) {
                    payload.list = list.map((item) => {
                        return {
                            customTemplate: true,
                            data: hookCustomTemplateService(item, payload),
                        };
                    });
                }
                const hasError = this.genFileFromTemplate(isGenJavaScript
                    ? (0, util_2.getFinalFileName)(`${tp.className}.js`)
                    : (0, util_2.getFinalFileName)(`${tp.className}.ts`), config_2.TypescriptFileType.serviceController, payload);
                prettierError.push(hasError);
                if (this.config.isGenReactQuery) {
                    this.genFileFromTemplate(isGenJavaScript
                        ? (0, util_2.getFinalFileName)(`${tp.className}.${reactQueryFileName}.js`)
                        : (0, util_2.getFinalFileName)(`${tp.className}.${reactQueryFileName}.ts`), config_2.TypescriptFileType.reactQuery, Object.assign({ namespace: this.config.namespace, requestOptionsType: this.config.requestOptionsType, requestImportStatement: this.config.requestImportStatement, interfaceFileName: config_2.interfaceFileName, reactQueryModePackageName: (0, config_1.displayReactQueryMode)(reactQueryMode) }, tp));
                }
            });
            if (prettierError.includes(true)) {
                (0, log_1.default)('ðŸš¥ æ ¼å¼åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥ service controller æ–‡ä»¶å†…å¯èƒ½å­˜åœ¨çš„è¯­æ³•é”™è¯¯');
            }
        }
        // å¤„ç†é‡å¤çš„ typeName
        this.interfaceTPConfigs = this.getInterfaceTPConfigs();
        (0, util_2.handleDuplicateTypeNames)(this.interfaceTPConfigs);
        // ç”Ÿæˆ ts ç±»åž‹å£°æ˜Ž
        if (!isGenJavaScript) {
            this.genFileFromTemplate(`${config_2.interfaceFileName}.ts`, config_2.TypescriptFileType.interface, {
                nullable: this.config.nullable,
                list: this.interfaceTPConfigs,
            });
        }
        // ç”Ÿæˆæžšä¸¾ç¿»è¯‘
        const enums = (0, lodash_1.filter)(this.interfaceTPConfigs, (item) => item.isEnum);
        if (!isGenJavaScript && !isOnlyGenTypeScriptType && !(0, lodash_1.isEmpty)(enums)) {
            const hookCustomTemplateService = (_b = (_a = this.config.hook) === null || _a === void 0 ? void 0 : _a.customTemplates) === null || _b === void 0 ? void 0 : _b[config_2.TypescriptFileType.displayEnumLabel];
            this.genFileFromTemplate(`${config_2.displayEnumLabelFileName}.ts`, config_2.TypescriptFileType.displayEnumLabel, {
                customTemplate: !!hookCustomTemplateService,
                list: hookCustomTemplateService
                    ? hookCustomTemplateService(enums, this.config)
                    : enums,
                namespace: this.config.namespace,
                interfaceFileName: config_2.interfaceFileName,
            });
        }
        const displayTypeLabels = (0, lodash_1.filter)(this.interfaceTPConfigs, (item) => !item.isEnum);
        // ç”Ÿæˆ type ç¿»è¯‘
        if (!isGenJavaScript &&
            !isOnlyGenTypeScriptType &&
            this.config.isDisplayTypeLabel &&
            !(0, lodash_1.isEmpty)(displayTypeLabels)) {
            const hookCustomTemplateService = (_d = (_c = this.config.hook) === null || _c === void 0 ? void 0 : _c.customTemplates) === null || _d === void 0 ? void 0 : _d[config_2.TypescriptFileType.displayTypeLabel];
            this.genFileFromTemplate(`${config_2.displayTypeLabelFileName}.ts`, config_2.TypescriptFileType.displayTypeLabel, {
                customTemplate: !!hookCustomTemplateService,
                list: hookCustomTemplateService
                    ? hookCustomTemplateService(enums, this.config)
                    : displayTypeLabels,
                namespace: this.config.namespace,
                interfaceFileName: config_2.interfaceFileName,
            });
        }
        if (!isOnlyGenTypeScriptType &&
            this.config.isGenJsonSchemas &&
            !(0, lodash_1.isEmpty)(this.schemaList)) {
            // å¤„ç†é‡å¤çš„ schemaName
            (0, util_2.handleDuplicateTypeNames)(this.schemaList);
            // ç”Ÿæˆ schema æ–‡ä»¶
            this.genFileFromTemplate(isGenJavaScript ? `${config_2.schemaFileName}.js` : `${config_2.schemaFileName}.ts`, config_2.TypescriptFileType.schema, {
                list: this.schemaList,
            });
        }
        // ç”Ÿæˆ service index æ–‡ä»¶
        this.genFileFromTemplate(isGenJavaScript
            ? `${config_2.serviceEntryFileName}.js`
            : `${config_2.serviceEntryFileName}.ts`, config_2.TypescriptFileType.serviceIndex, {
            list: this.classNameList,
            namespace: this.config.namespace,
            interfaceFileName: config_2.interfaceFileName,
            genType: isGenJavaScript ? config_2.LangType.js : config_2.LangType.ts,
            isGenJsonSchemas: !isOnlyGenTypeScriptType &&
                this.config.isGenJsonSchemas &&
                !(0, lodash_1.isEmpty)(this.schemaList),
            schemaFileName: config_2.schemaFileName,
            isDisplayEnumLabel: !isOnlyGenTypeScriptType && !(0, lodash_1.isEmpty)(enums),
            displayEnumLabelFileName: config_2.displayEnumLabelFileName,
            isGenReactQuery: this.config.isGenReactQuery,
            reactQueryFileName,
            isDisplayTypeLabel: !isOnlyGenTypeScriptType &&
                this.config.isDisplayTypeLabel &&
                !(0, lodash_1.isEmpty)(displayTypeLabels),
            displayTypeLabelFileName: config_2.displayTypeLabelFileName,
        });
        // æ‰“å°æ—¥å¿—
        (0, log_1.default)('âœ… æˆåŠŸç”Ÿæˆ api æ–‡ä»¶ç›®å½•-> ', `  ${this.config.serversPath}`);
    }
    getInterfaceTPConfigs() {
        var _a, _b, _c;
        const schemas = (_a = this.openAPIData.components) === null || _a === void 0 ? void 0 : _a.schemas;
        const lastTypes = this.interfaceTPConfigs;
        const includeTags = ((_b = this.config) === null || _b === void 0 ? void 0 : _b.includeTags) || [];
        const includePaths = ((_c = this.config) === null || _c === void 0 ? void 0 : _c.includePaths) || [];
        // å¼ºè¡Œæ›¿æ¢æŽ‰è¯·æ±‚å‚æ•°paramsçš„ç±»åž‹ï¼Œç”Ÿæˆæ–¹æ³•å¯¹åº”çš„ xxxxParams ç±»åž‹
        (0, lodash_1.keys)(this.openAPIData.paths).forEach((pathKey) => {
            const pathItem = this.openAPIData.paths[pathKey];
            (0, lodash_1.forEach)(config_2.methods, (method) => {
                var _a, _b, _c, _d;
                const operationObject = pathItem[method];
                const hookCustomFileNames = ((_a = this.config.hook) === null || _a === void 0 ? void 0 : _a.customFileNames) || util_2.getDefaultFileTag;
                if (!operationObject) {
                    return;
                }
                const tags = hookCustomFileNames(operationObject, pathKey, method);
                if ((0, lodash_1.isEmpty)(includeTags) ||
                    (!(0, lodash_1.isEmpty)(includeTags) && (0, lodash_1.isEmpty)(tags)) ||
                    (0, lodash_1.isEmpty)(includePaths)) {
                    return;
                }
                const flag = this.validateRegexp((0, lodash_1.filter)(tags, (tag) => !!tag), includeTags);
                const pathFlag = this.validateRegexp(pathKey, includePaths);
                if (!flag || !pathFlag) {
                    return;
                }
                // ç­›é€‰å‡º pathItem åŒ…å«çš„ $ref å¯¹åº”çš„schema
                (0, util_2.markAllowedSchema)(JSON.stringify(pathItem), this.openAPIData);
                operationObject.parameters = (_b = operationObject.parameters) === null || _b === void 0 ? void 0 : _b.filter((item) => {
                    const parameter = this.resolveParameterRef(item);
                    return (parameter === null || parameter === void 0 ? void 0 : parameter.in) !== `${config_2.parametersInsEnum.header}`;
                });
                const props = [];
                (_c = operationObject.parameters) === null || _c === void 0 ? void 0 : _c.forEach((param) => {
                    var _a;
                    const parameter = this.resolveParameterRef(param);
                    if (parameter) {
                        props.push({
                            name: parameter.name,
                            desc: ((_a = parameter.description) !== null && _a !== void 0 ? _a : '').replace(config_2.lineBreakReg, ''),
                            required: parameter.required || false,
                            type: this.getType(parameter.schema),
                        });
                    }
                });
                // parameters may be in path
                (_d = pathItem.parameters) === null || _d === void 0 ? void 0 : _d.forEach((param) => {
                    var _a;
                    const parameter = this.resolveParameterRef(param);
                    if (parameter) {
                        props.push({
                            name: parameter.name,
                            desc: ((_a = parameter.description) !== null && _a !== void 0 ? _a : '').replace(config_2.lineBreakReg, ''),
                            required: parameter.required,
                            type: this.getType(parameter.schema),
                        });
                    }
                });
                const typeName = this.getFunctionParamsTypeName(Object.assign(Object.assign({}, operationObject), { method, path: pathKey }));
                if (props.length > 0 && typeName) {
                    lastTypes.push({
                        typeName,
                        type: 'Record<string, unknown>',
                        props: [props],
                        isEnum: false,
                    });
                }
            });
        });
        (0, lodash_1.keys)(schemas).forEach((schemaKey) => {
            var _a;
            const schema = schemas[schemaKey];
            // åˆ¤æ–­å“ªäº› schema éœ€è¦æ·»åŠ è¿› type, schemas æ¸²æŸ“æ•°ç»„
            if (!(schema === null || schema === void 0 ? void 0 : schema.isAllowed)) {
                return;
            }
            const result = this.resolveObject(schema);
            const getDefinesType = () => {
                if (result === null || result === void 0 ? void 0 : result.type) {
                    return schema.type === 'object'
                        ? config_1.SchemaObjectType.object
                        : config_2.numberEnum.includes(result.type)
                            ? config_1.SchemaObjectType.number
                            : result.type;
                }
                return 'Record<string, unknown>';
            };
            // è§£æž props å±žæ€§ä¸­çš„æžšä¸¾
            if ((0, lodash_1.isArray)(result.props) && result.props.length > 0) {
                (0, lodash_1.forEach)(result.props[0], (item) => {
                    if (item.enum) {
                        const enumObj = this.resolveEnumObject(item);
                        lastTypes.push({
                            typeName: `${(0, lodash_1.upperFirst)(item.name)}Enum`,
                            type: enumObj.type,
                            props: [],
                            isEnum: enumObj.isEnum,
                            displayLabelFuncName: (0, util_1.camelCase)(`display-${item.name}-Enum`),
                            enumLabelType: enumObj.enumLabelType,
                            description: enumObj.description,
                        });
                    }
                });
            }
            const isEnum = result.isEnum;
            const typeName = (0, util_2.resolveTypeName)(schemaKey);
            if (typeName) {
                lastTypes.push({
                    typeName,
                    type: getDefinesType(),
                    props: (result.props || []),
                    isEnum,
                    displayLabelFuncName: isEnum
                        ? (0, util_1.camelCase)(`display-${typeName}-Enum`)
                        : '',
                    enumLabelType: isEnum ? result.enumLabelType : '',
                    description: result.description,
                });
            }
            if (this.config.isGenJsonSchemas) {
                this.schemaList.push({
                    typeName: `$${(0, lodash_1.lowerFirst)((0, util_2.resolveTypeName)(schemaKey))}`,
                    type: JSON.stringify((0, patchSchema_1.patchSchema)(schema, (_a = this.openAPIData.components) === null || _a === void 0 ? void 0 : _a.schemas)),
                });
            }
        });
        return lastTypes === null || lastTypes === void 0 ? void 0 : lastTypes.sort((a, b) => a.typeName.localeCompare(b.typeName)); // typeNameæŽ’åº
    }
    getServiceTPConfigs() {
        return (0, lodash_1.keys)(this.apiData)
            .map((tag, index) => {
            var _a, _b;
            // functionName tag çº§åˆ«é˜²é‡
            const tmpFunctionRD = {};
            const genParams = this.apiData[tag]
                .filter((api) => 
            // æš‚ä¸æ”¯æŒå˜é‡, path éœ€è¦æ™®é€šå‰ç¼€è¯·ä½¿ç”¨ä¾‹å¦‚: apiPrefix: "`api`", path éœ€è¦å˜é‡å‰ç¼€è¯·ä½¿ç”¨ä¾‹å¦‚: apiPrefix: "api"
            !api.path.includes('${'))
                .map((api) => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                const newApi = api;
                try {
                    const params = this.getParamsTP(newApi.parameters, newApi.path) || {};
                    const body = this.getBodyTP(newApi.requestBody, this.config.namespace);
                    const bodyWithoutNamespace = this.getBodyTP(newApi.requestBody);
                    const response = this.getResponseTP(newApi.responses);
                    const file = this.getFileTP(newApi.requestBody);
                    let formData = false;
                    if (((_a = body === null || body === void 0 ? void 0 : body.mediaType) === null || _a === void 0 ? void 0 : _a.includes('form-data')) || file) {
                        formData = true;
                    }
                    let functionName = this.getFunctionName(newApi);
                    if (functionName && tmpFunctionRD[functionName]) {
                        functionName = `${functionName}_${(tmpFunctionRD[functionName] += 1)}`;
                    }
                    else if (functionName) {
                        tmpFunctionRD[functionName] = 1;
                    }
                    if (body === null || body === void 0 ? void 0 : body.isAnonymous) {
                        const bodyName = (0, lodash_1.upperFirst)(`${functionName}Body`);
                        this.interfaceTPConfigs.push({
                            typeName: bodyName,
                            type: bodyWithoutNamespace === null || bodyWithoutNamespace === void 0 ? void 0 : bodyWithoutNamespace.type,
                            isEnum: false,
                            props: [],
                        });
                        body.type = `${this.config.namespace}.${bodyName}`;
                    }
                    if (response === null || response === void 0 ? void 0 : response.isAnonymous) {
                        const responseName = (0, lodash_1.upperFirst)(`${functionName}Response`);
                        // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ç§»é™¤ response?.type ä¸­åŒ…å« this.config.namespace çš„éƒ¨åˆ†ï¼ŒisAnonymousæ¨¡å¼ä¸éœ€è¦ this.config.namespace å‰ç¼€
                        const cleanType = ((_b = response === null || response === void 0 ? void 0 : response.type) === null || _b === void 0 ? void 0 : _b.includes(`${this.config.namespace}.`))
                            ? (_c = response === null || response === void 0 ? void 0 : response.type) === null || _c === void 0 ? void 0 : _c.replace(new RegExp(`${this.config.namespace}\\.`, 'g'), '')
                            : (response === null || response === void 0 ? void 0 : response.type) || '';
                        this.interfaceTPConfigs.push({
                            typeName: responseName,
                            type: cleanType,
                            isEnum: false,
                            props: [],
                        });
                        response.type = `${this.config.namespace}.${responseName}`;
                    }
                    const responsesType = this.getResponsesType(newApi.responses, functionName);
                    // å¦‚æžœæœ‰å¤šä¸ªå“åº”ç±»åž‹ï¼Œç”Ÿæˆå¯¹åº”çš„ç±»åž‹å®šä¹‰
                    if (responsesType) {
                        this.interfaceTPConfigs.push({
                            typeName: (0, lodash_1.upperFirst)(`${functionName}Responses`),
                            type: responsesType,
                            isEnum: false,
                            props: [],
                        });
                    }
                    let formattedPath = newApi.path.replace(/:([^/]*)|{([^}]*)}/gi, (_, str, str2) => `$\{${str || str2}}`);
                    // ä¸º path ä¸­çš„ params æ·»åŠ  alias
                    const escapedPathParams = (0, lodash_1.map)(params.path, (item, index) => (Object.assign(Object.assign({}, item), { alias: `param${index}` })));
                    if (escapedPathParams.length) {
                        escapedPathParams.forEach((param) => {
                            formattedPath = formattedPath.replace(`$\{${param.name}}`, `$\{${param.alias}}`);
                        });
                    }
                    const finalParams = escapedPathParams && escapedPathParams.length
                        ? Object.assign(Object.assign({}, params), { path: escapedPathParams }) : params;
                    // å¤„ç† query ä¸­çš„å¤æ‚å¯¹è±¡
                    if (finalParams === null || finalParams === void 0 ? void 0 : finalParams.query) {
                        finalParams.query = finalParams.query.map((item) => (Object.assign(Object.assign({}, item), { isComplexType: item.isObject })));
                    }
                    // å¤„ç† api path å‰ç¼€
                    const getPrefixPath = () => {
                        if (!this.config.apiPrefix) {
                            return formattedPath;
                        }
                        // é™æ€ apiPrefix
                        const prefix = (0, lodash_1.isFunction)(this.config.apiPrefix)
                            ? `${this.config.apiPrefix({
                                path: formattedPath,
                                method: newApi.method,
                                namespace: tag,
                                functionName,
                            })}`.trim()
                            : this.config.apiPrefix.trim();
                        if (!prefix) {
                            return formattedPath;
                        }
                        if (prefix.startsWith("'") ||
                            prefix.startsWith('"') ||
                            prefix.startsWith('`')) {
                            const finalPrefix = prefix.slice(1, prefix.length - 1);
                            const firstPath = formattedPath.split('/')[1];
                            if (firstPath === finalPrefix ||
                                `/${firstPath}` === finalPrefix) {
                                return formattedPath;
                            }
                            return `${finalPrefix}${formattedPath}`;
                        }
                        // prefix å˜é‡
                        return `$\{${prefix}}${formattedPath}`;
                    };
                    return Object.assign(Object.assign({}, newApi), { functionName: this.config.isCamelCase
                            ? (0, util_1.camelCase)(functionName)
                            : functionName, typeName: this.getFunctionParamsTypeName(newApi), path: getPrefixPath(), pathInComment: formattedPath.replace(/\*/g, '&#42;'), apifoxRunLink: newApi === null || newApi === void 0 ? void 0 : newApi['x-run-in-apifox'], hasPathVariables: formattedPath.includes('{'), hasApiPrefix: !!this.config.apiPrefix, method: newApi.method, 
                        // å¦‚æžœ functionName å’Œ summary ç›¸åŒï¼Œåˆ™ä¸æ˜¾ç¤º summary
                        desc: functionName === newApi.summary
                            ? (newApi.description || '').replace(config_2.lineBreakReg, '')
                            : [
                                newApi.summary,
                                newApi.description,
                                ((_e = (_d = newApi.responses) === null || _d === void 0 ? void 0 : _d.default) === null || _e === void 0 ? void 0 : _e.description)
                                    ? `è¿”å›žå€¼: ${((_f = newApi.responses) === null || _f === void 0 ? void 0 : _f.default).description}`
                                    : '',
                            ]
                                .filter((s) => s)
                                .join(' ')
                                .replace(config_2.lineBreakReg, ''), hasHeader: !!(params === null || params === void 0 ? void 0 : params.header) || !!(body === null || body === void 0 ? void 0 : body.mediaType), params: finalParams, hasParams: Boolean((0, lodash_1.keys)(finalParams).length), options: ((_h = (_g = this.config.hook) === null || _g === void 0 ? void 0 : _g.customOptionsDefaultValue) === null || _h === void 0 ? void 0 : _h.call(_g, newApi)) || {}, body,
                        file, hasFormData: formData, response });
                }
                catch (error) {
                    console.error('[GenSDK] gen service param error:', error);
                    throw error;
                }
            })
                // æŽ’åºä¸‹ï¼Œé˜²æ­¢gitä¹±
                .sort((a, b) => a.path.localeCompare(b.path));
            const fileName = (0, util_2.replaceDot)(tag) || `api${index}`;
            let className = fileName;
            if ((_a = this.config.hook) === null || _a === void 0 ? void 0 : _a.customClassName) {
                className = this.config.hook.customClassName(tag);
            }
            if (genParams.length) {
                this.classNameList.push({
                    fileName: className,
                    controllerName: className,
                });
            }
            return {
                genType: this.config.isGenJavaScript ? config_2.LangType.js : config_2.LangType.ts,
                className,
                instanceName: `${(_b = fileName[0]) === null || _b === void 0 ? void 0 : _b.toLowerCase()}${fileName.slice(1)}`,
                list: genParams,
            };
        })
            .filter((item) => { var _a; return !!((_a = item === null || item === void 0 ? void 0 : item.list) === null || _a === void 0 ? void 0 : _a.length); });
    }
    genFileFromTemplate(fileName, type, params) {
        var _a;
        try {
            const template = this.getTemplate(type);
            // åº”ç”¨ customRenderTemplateData hook (å¦‚æžœå­˜åœ¨)
            let processedParams = Object.assign({}, params);
            const customListHooks = (_a = this.config.hook) === null || _a === void 0 ? void 0 : _a.customRenderTemplateData;
            if (customListHooks && params.list) {
                try {
                    const context = {
                        fileName,
                        params: processedParams,
                    };
                    let processedList = params.list;
                    // æ ¹æ®ä¸åŒçš„æ–‡ä»¶ç±»åž‹è°ƒç”¨ç›¸åº”çš„ hook å‡½æ•°
                    switch (type) {
                        case config_2.TypescriptFileType.serviceController:
                            if (customListHooks.serviceController) {
                                processedList = customListHooks.serviceController(params.list, context);
                            }
                            break;
                        case config_2.TypescriptFileType.reactQuery:
                            if (customListHooks.reactQuery) {
                                processedList = customListHooks.reactQuery(params.list, context);
                            }
                            break;
                        case config_2.TypescriptFileType.interface:
                            if (customListHooks.interface) {
                                processedList = customListHooks.interface(params.list, context);
                            }
                            break;
                        case config_2.TypescriptFileType.displayEnumLabel:
                            if (customListHooks.displayEnumLabel) {
                                processedList = customListHooks.displayEnumLabel(params.list, context);
                            }
                            break;
                        case config_2.TypescriptFileType.displayTypeLabel:
                            if (customListHooks.displayTypeLabel) {
                                processedList = customListHooks.displayTypeLabel(params.list, context);
                            }
                            break;
                        case config_2.TypescriptFileType.schema:
                            if (customListHooks.schema) {
                                processedList = customListHooks.schema(params.list, context);
                            }
                            break;
                        case config_2.TypescriptFileType.serviceIndex:
                            if (customListHooks.serviceIndex) {
                                processedList = customListHooks.serviceIndex(params.list, context);
                            }
                            break;
                    }
                    if (processedList !== params.list) {
                        processedParams = Object.assign(Object.assign({}, processedParams), { list: processedList });
                        this.log(`customRenderTemplateData hook applied for ${type}: ${fileName}`);
                    }
                }
                catch (error) {
                    console.error(`[GenSDK] customRenderTemplateData hook error for ${type}:`, error);
                    this.log(`customRenderTemplateData hook failed for ${type}, using original list`);
                    // å‘ç”Ÿé”™è¯¯æ—¶ä½¿ç”¨åŽŸå§‹å‚æ•°ç»§ç»­æ‰§è¡Œ
                }
            }
            // è®¾ç½®è¾“å‡ºä¸è½¬ä¹‰
            const env = nunjucks_1.default.configure({
                autoescape: false,
            });
            env.addFilter('capitalizeFirst', util_2.capitalizeFirstLetter);
            const destPath = (0, path_1.join)(this.config.serversPath, fileName);
            const destCode = nunjucks_1.default.renderString(template, Object.assign({ disableTypeCheck: false }, processedParams));
            let mergerProps = {};
            if ((0, fs_1.existsSync)(destPath)) {
                mergerProps = {
                    srcPath: destPath,
                };
            }
            else {
                mergerProps = {
                    source: '',
                };
            }
            if (this.config.full) {
                return (0, file_1.writeFile)(this.config.serversPath, fileName, destCode);
            }
            const merger = new merge_1.Merger(mergerProps);
            return (0, file_1.writeFile)(this.config.serversPath, fileName, merger.merge({
                source: destCode,
            }));
        }
        catch (error) {
            console.error('[GenSDK] file gen fail:', fileName, 'type:', type);
            throw error;
        }
    }
    getTemplate(type) {
        return (0, fs_1.readFileSync)((0, path_1.join)(this.config.templatesFolder, `${type}.njk`), 'utf8');
    }
    // ç”Ÿæˆæ–¹æ³•å functionName
    getFunctionName(data) {
        // èŽ·å–è·¯å¾„ç›¸åŒéƒ¨åˆ†
        const pathBasePrefix = (0, util_2.getBasePrefix)((0, lodash_1.keys)(this.openAPIData.paths));
        return this.config.hook && this.config.hook.customFunctionName
            ? this.config.hook.customFunctionName(data, pathBasePrefix)
            : (0, util_1.camelCase)(`${(0, util_2.genDefaultFunctionName)(data.path, pathBasePrefix)}-using-${data.method}`);
        // return this.config.hook && this.config.hook.customFunctionName
        //   ? this.config.hook.customFunctionName(data)
        //   : data.operationId
        //     ? resolveFunctionName(stripDot(data.operationId), data.method)
        //     : data.method + genDefaultFunctionName(data.path, pathBasePrefix);
    }
    getType(schemaObject, namespace) {
        var _a, _b;
        const customTypeHookFunc = (_a = this.config.hook) === null || _a === void 0 ? void 0 : _a.customType;
        const schemas = (_b = this.openAPIData.components) === null || _b === void 0 ? void 0 : _b.schemas;
        if (customTypeHookFunc) {
            const type = customTypeHookFunc({
                schemaObject,
                namespace,
                schemas,
                originGetType: util_2.getDefaultType,
            });
            if (typeof type === 'string') {
                return type;
            }
        }
        return (0, util_2.getDefaultType)(schemaObject, namespace, schemas);
    }
    getFunctionParamsTypeName(data) {
        var _a, _b, _c;
        const namespace = this.config.namespace ? `${this.config.namespace}.` : '';
        const typeName = ((_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.customTypeName) === null || _c === void 0 ? void 0 : _c.call(_b, data)) || this.getFunctionName(data);
        return (0, lodash_1.upperFirst)((0, util_2.resolveTypeName)(`${namespace}${typeName !== null && typeName !== void 0 ? typeName : data.operationId}Params`));
    }
    getBodyTP(requestBody, namespace) {
        var _a;
        const reqBody = this.resolveRefObject(requestBody);
        if ((0, lodash_1.isEmpty)(reqBody)) {
            return null;
        }
        const reqContent = reqBody.content;
        if (!(0, lodash_1.isObject)(reqContent)) {
            return null;
        }
        let mediaType = (0, lodash_1.keys)(reqContent)[0];
        const schema = ((_a = reqContent[mediaType]) === null || _a === void 0 ? void 0 : _a.schema) || config_2.DEFAULT_SCHEMA;
        if (mediaType === '*/*') {
            mediaType = '';
        }
        // å¦‚æžœ requestBody æœ‰ required å±žæ€§ï¼Œåˆ™æ­£å¸¸å±•ç¤ºï¼›å¦‚æžœæ²¡æœ‰ï¼Œé»˜è®¤éžå¿…å¡«
        const required = typeof (requestBody === null || requestBody === void 0 ? void 0 : requestBody.required) === 'boolean' ? requestBody.required : false;
        const bodySchema = {
            mediaType,
            required,
            type: this.getType(schema, namespace),
            isAnonymous: false,
        };
        // åŒ¿å body åœºæ™¯
        if (!(0, util_2.isReferenceObject)(schema)) {
            bodySchema.isAnonymous = true;
        }
        return bodySchema;
    }
    getFileTP(requestBody) {
        var _a;
        const reqBody = this.resolveRefObject(requestBody);
        if ((_a = reqBody === null || reqBody === void 0 ? void 0 : reqBody.content) === null || _a === void 0 ? void 0 : _a['multipart/form-data']) {
            const ret = this.resolveFileTP(reqBody.content['multipart/form-data'].schema);
            return ret.length > 0 ? ret : null;
        }
        return null;
    }
    resolveFileTP(obj) {
        var _a;
        let ret = [];
        const resolved = this.resolveObject(obj);
        const props = (((_a = resolved.props) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
            resolved.props[0].filter((p) => p.format === 'binary' ||
                p.format === 'base64' ||
                (0, util_2.isBinaryArraySchemaObject)(p))) ||
            [];
        if (props.length > 0) {
            ret = props.map((p) => {
                // è¿™é‡Œ p.type æ˜¯è‡ªå®šä¹‰type, æ³¨æ„åˆ«æ··æ·†
                return {
                    title: p.name,
                    multiple: p.type === `${config_1.SchemaObjectType.array}` ||
                        p.type === `${config_1.SchemaObjectType.stringArray}`,
                };
            });
        }
        if (resolved.type) {
            ret = [...ret, ...this.resolveFileTP(resolved.type)];
        }
        return ret;
    }
    getResponseTP(responses = {}) {
        var _a;
        const { components } = this.openAPIData;
        const response = responses &&
            this.resolveRefObject(responses['200'] || responses['201'] || responses.default);
        const defaultResponse = {
            mediaType: '*/*',
            type: 'unknown',
            isAnonymous: false,
            responseType: undefined,
        };
        if (!response) {
            return defaultResponse;
        }
        const resContent = response.content;
        const resContentMediaTypes = (0, lodash_1.keys)(resContent);
        // æ£€æµ‹äºŒè¿›åˆ¶æµåª’ä½“ç±»åž‹
        const binaryMediaTypes = (0, util_2.getBinaryMediaTypes)(this.config.binaryMediaTypes);
        const binaryMediaType = resContentMediaTypes.find((mediaType) => (0, util_2.isBinaryMediaType)(mediaType, binaryMediaTypes));
        const mediaType = resContentMediaTypes.includes('application/json')
            ? 'application/json'
            : binaryMediaType || resContentMediaTypes[0]; // ä¼˜å…ˆä½¿ç”¨ application/jsonï¼Œç„¶åŽæ˜¯äºŒè¿›åˆ¶ç±»åž‹
        if (!(0, lodash_1.isObject)(resContent) || !mediaType) {
            return defaultResponse;
        }
        let schema = (resContent[mediaType].schema ||
            config_2.DEFAULT_SCHEMA);
        const responseSchema = {
            mediaType,
            type: 'unknown',
            isAnonymous: false,
            responseType: undefined,
        };
        // å¦‚æžœæ˜¯äºŒè¿›åˆ¶åª’ä½“ç±»åž‹ï¼Œç›´æŽ¥è¿”å›žäºŒè¿›åˆ¶ç±»åž‹
        if ((0, util_2.isBinaryMediaType)(mediaType, binaryMediaTypes)) {
            const binaryType = (0, util_2.getBinaryResponseType)();
            responseSchema.type = binaryType;
            // è‡ªåŠ¨ä¸ºäºŒè¿›åˆ¶å“åº”æ·»åŠ  responseType é…ç½®
            responseSchema.responseType = (0, util_2.getAxiosResponseType)(binaryType);
            return responseSchema;
        }
        if ((0, util_2.isReferenceObject)(schema)) {
            const refName = (0, util_2.getLastRefName)(schema.$ref);
            const childrenSchema = components.schemas[refName];
            if ((0, util_2.isNonArraySchemaObject)(childrenSchema) && this.config.dataFields) {
                schema = (((_a = this.config.dataFields
                    .map((field) => childrenSchema.properties[field])
                    .filter(Boolean)) === null || _a === void 0 ? void 0 : _a[0]) ||
                    resContent[mediaType].schema ||
                    config_2.DEFAULT_SCHEMA);
            }
            responseSchema.type = this.getType(schema, this.config.namespace);
            return responseSchema;
        }
        if ((0, util_2.isSchemaObject)(schema)) {
            (0, lodash_1.keys)(schema.properties).map((fieldName) => {
                var _a, _b;
                schema.properties[fieldName]['required'] =
                    (_b = (_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(fieldName)) !== null && _b !== void 0 ? _b : false;
            });
            responseSchema.isAnonymous = true;
        }
        responseSchema.type = this.getType(schema, this.config.namespace);
        return responseSchema;
    }
    /**
     * ç”Ÿæˆå¤šçŠ¶æ€ç å“åº”ç±»åž‹å®šä¹‰
     * å°† OpenAPI çš„ responses å¯¹è±¡è½¬æ¢ä¸º TypeScript ç±»åž‹å®šä¹‰
     * ä¾‹å¦‚ï¼š{ 200: ResponseType, 400: unknown, 404: unknown }
     *
     * @param responses OpenAPI å“åº”å¯¹è±¡
     * @param functionName å‡½æ•°åç§°ï¼Œç”¨äºŽç”Ÿæˆä¸»å“åº”ç±»åž‹åç§°
     * @returns å¤šçŠ¶æ€ç å“åº”ç±»åž‹å®šä¹‰å­—ç¬¦ä¸²ï¼Œå¦‚æžœæ²¡æœ‰å“åº”åˆ™è¿”å›ž null
     */
    getResponsesType(responses = {}, functionName) {
        if ((0, lodash_1.isEmpty)(responses) ||
            ~(0, lodash_1.findIndex)(this.interfaceTPConfigs, (item) => item.typeName === (0, lodash_1.upperFirst)(`${functionName}Responses`))) {
            return null;
        }
        const { components } = this.openAPIData;
        // ç”Ÿæˆä¸»å“åº”ç±»åž‹åç§°
        const mainResponseTypeName = (0, lodash_1.upperFirst)(`${functionName}Response`);
        const responseEntries = this.parseResponseEntries(responses, components);
        const responseTypes = responseEntries.map(({ statusCode, type, description = '' }) => {
            var _a;
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨å¯¹åº”çš„ä¸»å“åº”ç±»åž‹ï¼Œå¦‚æžœå­˜åœ¨åˆ™å¤ç”¨ï¼Œé¿å…é‡å¤å®šä¹‰
            const existType = this.interfaceTPConfigs.find((item) => item.typeName === mainResponseTypeName);
            const lastType = existType ? mainResponseTypeName : type;
            // æ ¼å¼åŒ–æè¿°æ–‡æœ¬ï¼Œè®©æè¿°æ”¯æŒæ¢è¡Œ
            const formattedDescription = config_2.lineBreakReg.test(description)
                ? (_a = description.split('\n')) === null || _a === void 0 ? void 0 : _a.join('\n * ')
                : description;
            // ç”Ÿæˆå¸¦æ³¨é‡Šçš„ç±»åž‹å®šä¹‰
            return formattedDescription
                ? `  /**\n   * ${formattedDescription}\n   */\n  ${statusCode}: ${lastType};`
                : `  ${statusCode}: ${lastType};`;
        });
        // è¿”å›žå®Œæ•´çš„å¯¹è±¡ç±»åž‹å®šä¹‰
        return `{\n${responseTypes.join('\n')}\n}`;
    }
    /**
     * è§£æžå“åº”æ¡ç›®ï¼Œæå–æ¯ä¸ªçŠ¶æ€ç å¯¹åº”çš„ç±»åž‹å’Œæè¿°ä¿¡æ¯
     *
     * @param responses OpenAPI å“åº”å¯¹è±¡
     * @param components OpenAPI ç»„ä»¶å¯¹è±¡ï¼Œç”¨äºŽè§£æžå¼•ç”¨ç±»åž‹
     * @returns å“åº”æ¡ç›®æ•°ç»„ï¼ŒåŒ…å«çŠ¶æ€ç ã€ç±»åž‹å’Œæè¿°
     */
    parseResponseEntries(responses, components) {
        return (0, lodash_1.keys)(responses).map((statusCode) => {
            const response = this.resolveRefObject(responses[statusCode]);
            if (!response) {
                return { statusCode, type: 'unknown', description: '' };
            }
            const responseType = this.getResponseTypeFromContent(response, components);
            const description = response.description || '';
            return { statusCode, type: responseType, description };
        });
    }
    /**
     * ä»Žå“åº”å†…å®¹ä¸­æå– TypeScript ç±»åž‹
     * å¤„ç†ä¸åŒçš„åª’ä½“ç±»åž‹å’Œ schema ç±»åž‹
     *
     * @param response å“åº”å¯¹è±¡
     * @param components OpenAPI ç»„ä»¶å¯¹è±¡
     * @returns TypeScript ç±»åž‹å­—ç¬¦ä¸²
     */
    getResponseTypeFromContent(response, components) {
        var _a;
        if (!response.content) {
            return 'unknown';
        }
        const resContent = response.content;
        const resContentMediaTypes = (0, lodash_1.keys)(resContent);
        // æ£€æµ‹äºŒè¿›åˆ¶æµåª’ä½“ç±»åž‹
        const binaryMediaTypes = (0, util_2.getBinaryMediaTypes)(this.config.binaryMediaTypes);
        const binaryMediaType = resContentMediaTypes.find((mediaType) => (0, util_2.isBinaryMediaType)(mediaType, binaryMediaTypes));
        const mediaType = resContentMediaTypes.includes('application/json')
            ? 'application/json'
            : binaryMediaType || resContentMediaTypes[0];
        if (!(0, lodash_1.isObject)(resContent) || !mediaType) {
            return 'unknown';
        }
        // å¦‚æžœæ˜¯äºŒè¿›åˆ¶åª’ä½“ç±»åž‹ï¼Œç›´æŽ¥è¿”å›žäºŒè¿›åˆ¶ç±»åž‹
        if ((0, util_2.isBinaryMediaType)(mediaType, binaryMediaTypes)) {
            return (0, util_2.getBinaryResponseType)();
        }
        let schema = (resContent[mediaType].schema ||
            config_2.DEFAULT_SCHEMA);
        if ((0, util_2.isReferenceObject)(schema)) {
            const refName = (0, util_2.getLastRefName)(schema.$ref);
            const childrenSchema = components.schemas[refName];
            // å¦‚æžœé…ç½®äº† dataFieldsï¼Œå°è¯•ä»ŽæŒ‡å®šå­—æ®µæå–ç±»åž‹
            if ((0, util_2.isNonArraySchemaObject)(childrenSchema) && this.config.dataFields) {
                schema = (((_a = this.config.dataFields
                    .map((field) => childrenSchema.properties[field])
                    .filter(Boolean)) === null || _a === void 0 ? void 0 : _a[0]) ||
                    resContent[mediaType].schema ||
                    config_2.DEFAULT_SCHEMA);
            }
            return this.getType(schema);
        }
        else if ((0, util_2.isSchemaObject)(schema)) {
            // è®¾ç½®å±žæ€§çš„ required çŠ¶æ€
            (0, lodash_1.keys)(schema.properties).map((fieldName) => {
                var _a, _b;
                schema.properties[fieldName]['required'] =
                    (_b = (_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(fieldName)) !== null && _b !== void 0 ? _b : false;
            });
            return this.getType(schema);
        }
        else {
            return this.getType(schema);
        }
    }
    getParamsTP(parameters = [], path = null) {
        const templateParams = {};
        if (parameters === null || parameters === void 0 ? void 0 : parameters.length) {
            (0, lodash_1.forEach)(config_2.parametersIn, (source) => {
                const params = parameters
                    .map((p) => this.resolveRefObject(p))
                    .filter((p) => p.in === source)
                    .map((p) => {
                    var _a, _b, _c, _d, _e;
                    const isDirectObject = (((_a = p.schema) === null || _a === void 0 ? void 0 : _a.type) === 'object' ||
                        p.type) === 'object';
                    const refName = (0, util_2.getLastRefName)(((_b = p.schema) === null || _b === void 0 ? void 0 : _b.$ref) ||
                        p.$ref);
                    const deRefObj = (0, lodash_1.entries)((_c = this.openAPIData.components) === null || _c === void 0 ? void 0 : _c.schemas).find(([k]) => k === refName) || [];
                    const isRefObject = ((_d = deRefObj[1]) === null || _d === void 0 ? void 0 : _d.type) === 'object' &&
                        !(0, lodash_1.isEmpty)((_e = deRefObj[1]) === null || _e === void 0 ? void 0 : _e.properties);
                    return Object.assign(Object.assign({}, p), { isObject: isDirectObject || isRefObject, type: this.getType(p.schema || config_2.DEFAULT_SCHEMA, this.config.namespace) });
                });
                if (params.length) {
                    templateParams[source] = params;
                }
            });
        }
        if (path && path.length > 0) {
            const regex = /\{(\w+)\}/g;
            templateParams.path = templateParams.path || [];
            let match = null;
            while ((match = regex.exec(path))) {
                if (!templateParams.path.some((p) => p.name === match[1])) {
                    templateParams.path.push(Object.assign(Object.assign({}, config_2.DEFAULT_PATH_PARAM), { name: match[1] }));
                }
            }
            // å¦‚æžœ path æ²¡æœ‰å†…å®¹ï¼Œåˆ™å°†åˆ é™¤ path å‚æ•°ï¼Œé¿å…å½±å“åŽç»­çš„ hasParams åˆ¤æ–­
            if (!templateParams.path.length)
                delete templateParams.path;
        }
        return templateParams;
    }
    resolveObject(schemaObject) {
        // ä¸ä½¿ç”¨ schemaObject: ISchemaObject = {}
        schemaObject = schemaObject !== null && schemaObject !== void 0 ? schemaObject : {};
        // å¼•ç”¨ç±»åž‹
        if ((0, util_2.isReferenceObject)(schemaObject)) {
            return this.resolveRefObject(schemaObject);
        }
        // æžšä¸¾ç±»åž‹
        if (schemaObject.enum) {
            return this.resolveEnumObject(schemaObject);
        }
        // ç»§æ‰¿ç±»åž‹
        if (schemaObject.allOf && schemaObject.allOf.length) {
            return this.resolveAllOfObject(schemaObject);
        }
        // å¯¹è±¡ç±»åž‹
        if (schemaObject.properties) {
            return this.resolveProperties(schemaObject);
        }
        // æ•°ç»„ç±»åž‹
        if ((0, util_2.isArraySchemaObject)(schemaObject)) {
            return this.resolveArray(schemaObject);
        }
        return schemaObject;
    }
    resolveArray(schemaObject) {
        var _a;
        if ((0, util_2.isReferenceObject)(schemaObject.items)) {
            const refName = (0, util_2.getRefName)(schemaObject.items);
            return {
                type: `${refName}[]`,
            };
        }
        else if ((_a = schemaObject.items) === null || _a === void 0 ? void 0 : _a.enum) {
            return {
                type: this.getType(schemaObject, this.config.namespace),
            };
        }
        // è¿™é‡Œéœ€è¦è§£æžå‡ºå…·ä½“å±žæ€§ï¼Œä½†ç”±äºŽ parser å±‚è¿˜ä¸ç¡®å®šï¼Œæ‰€ä»¥æš‚æ—¶å…ˆè¿”å›ž unknown[]
        return { type: 'unknown[]' };
    }
    resolveProperties(schemaObject) {
        return {
            props: [this.getProps(schemaObject)],
        };
    }
    resolveEnumObject(schemaObject) {
        var _a;
        const enumArray = schemaObject.enum;
        let enumStr = '';
        let enumLabelTypeStr = '';
        if (config_2.numberEnum.includes(schemaObject.type) || (0, util_2.isAllNumber)(enumArray)) {
            if (this.config.isSupportParseEnumDesc && schemaObject.description) {
                const enumMap = (0, util_2.parseDescriptionEnum)(schemaObject.description);
                enumStr = `{${(0, lodash_1.map)(enumArray, (value) => {
                    const enumLabel = enumMap.get(Number(value));
                    return `${enumLabel}=${Number(value)}`;
                }).join(',')}}`;
            }
            else {
                enumStr = `{${(0, lodash_1.map)(enumArray, (value) => `"NUMBER_${value}"=${Number(value)}`).join(',')}}`;
            }
        }
        else if ((0, util_2.isAllNumeric)(enumArray)) {
            enumStr = `{${(0, lodash_1.map)(enumArray, (value) => `"STRING_NUMBER_${value}"="${value}"`).join(',')}}`;
        }
        else {
            enumStr = `{${(0, lodash_1.map)(enumArray, (value) => `"${value}"="${value}"`).join(',')}}`;
        }
        // ç¿»è¯‘æžšä¸¾
        if (schemaObject['x-enum-varnames'] && schemaObject['x-enum-comments']) {
            enumLabelTypeStr = `{${(0, lodash_1.map)(enumArray, (value, index) => {
                const enumKey = schemaObject['x-enum-varnames'][index];
                return `${value}:"${schemaObject['x-enum-comments'][enumKey]}"`;
            }).join(',')}}`;
        }
        else if ((_a = schemaObject === null || schemaObject === void 0 ? void 0 : schemaObject['x-apifox']) === null || _a === void 0 ? void 0 : _a['enumDescriptions']) {
            enumLabelTypeStr = `{${(0, lodash_1.map)(enumArray, (value) => {
                const enumLabel = schemaObject['x-apifox']['enumDescriptions'][value];
                return `${value}:"${enumLabel}"`;
            }).join(',')}}`;
        }
        else if (schemaObject === null || schemaObject === void 0 ? void 0 : schemaObject['x-apifox-enum']) {
            enumLabelTypeStr = `{${(0, lodash_1.map)(enumArray, (value) => {
                var _a;
                const enumLabel = (_a = (0, lodash_1.find)(schemaObject['x-apifox-enum'], (item) => item.value === value)) === null || _a === void 0 ? void 0 : _a.description;
                return `${value}:"${enumLabel}"`;
            }).join(',')}}`;
        }
        else {
            if (config_2.numberEnum.includes(schemaObject.type) || (0, util_2.isAllNumber)(enumArray)) {
                if (this.config.isSupportParseEnumDesc && schemaObject.description) {
                    const enumMap = (0, util_2.parseDescriptionEnum)(schemaObject.description);
                    enumLabelTypeStr = `{${(0, lodash_1.map)(enumArray, (value) => {
                        const enumLabel = enumMap.get(Number(value));
                        return `${Number(value)}:"${enumLabel}"`;
                    }).join(',')}}`;
                }
                else {
                    enumLabelTypeStr = `{${(0, lodash_1.map)(enumArray, (value) => `${Number(value) >= 0 ? Number(value) : `"${value}"`}:"NUMBER_${value}"`).join(',')}}`;
                }
            }
            else if ((0, util_2.isAllNumeric)(enumArray)) {
                enumLabelTypeStr = `{${(0, lodash_1.map)(enumArray, (value) => `"${value}":"STRING_NUMBER_${value}"`).join(',')}}`;
            }
            else {
                enumLabelTypeStr = `{${(0, lodash_1.map)(enumArray, (value) => `"${value}":"${value}"`).join(',')}}`;
            }
        }
        return {
            isEnum: true,
            type: Array.isArray(enumArray) ? enumStr : 'string',
            enumLabelType: enumLabelTypeStr,
            description: schemaObject.description,
        };
    }
    resolveAllOfObject(schemaObject) {
        const props = (0, lodash_1.map)(schemaObject.allOf, (item) => {
            return (0, util_2.isReferenceObject)(item)
                ? [Object.assign(Object.assign({}, item), { type: this.getType(item) })]
                : this.getProps(item);
        });
        if (schemaObject.properties) {
            const extProps = this.getProps(schemaObject);
            return { props: [...props, extProps] };
        }
        return { props };
    }
    // èŽ·å– TS ç±»åž‹çš„å±žæ€§åˆ—è¡¨
    getProps(schemaObject) {
        var _a;
        const requiredPropKeys = (_a = schemaObject === null || schemaObject === void 0 ? void 0 : schemaObject.required) !== null && _a !== void 0 ? _a : false;
        const properties = schemaObject.properties;
        return (0, lodash_1.keys)(properties).map((propKey) => {
            const schema = ((properties === null || properties === void 0 ? void 0 : properties[propKey]) || config_2.DEFAULT_SCHEMA);
            // å‰”é™¤å±žæ€§é”®å€¼ä¸­çš„ç‰¹æ®Šç¬¦å·ï¼Œå› ä¸ºå‡½æ•°å…¥å‚å˜é‡å­˜åœ¨ç‰¹æ®Šç¬¦å·ä¼šå¯¼è‡´è§£æžæ–‡ä»¶å¤±è´¥
            // eslint-disable-next-line no-useless-escape
            propKey = propKey.replace(/[\[|\]]/g, '');
            // å¤ç”¨ schema éƒ¨åˆ†å­—æ®µ
            return Object.assign(Object.assign({}, schema), { name: propKey, type: this.getType(schema), desc: [schema.title, schema.description]
                    .filter((item) => item)
                    .join(' ')
                    .replace(config_2.lineBreakReg, ''), 
                // å¦‚æžœæ²¡æœ‰ required ä¿¡æ¯ï¼Œé»˜è®¤å…¨éƒ¨æ˜¯éžå¿…å¡«
                required: requiredPropKeys
                    ? requiredPropKeys.some((key) => key === propKey)
                    : false });
        });
    }
    resolveParameterRef(param) {
        var _a, _b;
        if (!(0, util_2.isReferenceObject)(param)) {
            return param;
        }
        // è§£æž $ref å¼•ç”¨ï¼Œä»Ž components.parameters ä¸­èŽ·å–å®žé™…å®šä¹‰
        const refName = (0, util_2.getLastRefName)(param.$ref);
        const parameter = (_b = (_a = this.openAPIData.components) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 : _b[refName];
        return parameter || null;
    }
    resolveRefObject(refObject) {
        if (!(0, util_2.isReferenceObject)(refObject)) {
            return refObject;
        }
        const refPaths = refObject.$ref.split('/');
        if (refPaths[0] === '#') {
            const schema = (0, util_2.resolveRefs)(this.openAPIData, refPaths.slice(1));
            if (!schema) {
                throw new Error(`[GenSDK] Data Error! Notfoud: ${refObject.$ref}`);
            }
            return Object.assign(Object.assign({}, (this.resolveRefObject(schema) || {})), { type: (0, util_2.isReferenceObject)(schema)
                    ? this.resolveRefObject(schema).type
                    : schema.type });
        }
        return refObject;
    }
    log(message) {
        if (this.config.enableLogging) {
            (0, log_1.default)(message);
        }
    }
    generateInfoLog() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this.log(`priorityRule: ${(_a = this.config) === null || _a === void 0 ? void 0 : _a.priorityRule}`);
        if ((_b = this.config) === null || _b === void 0 ? void 0 : _b.includeTags) {
            this.log(`includeTags: ${(_c = this.config) === null || _c === void 0 ? void 0 : _c.includeTags.join(', ')}`);
        }
        if ((_d = this.config) === null || _d === void 0 ? void 0 : _d.excludeTags) {
            this.log(`excludeTags: ${(_e = this.config) === null || _e === void 0 ? void 0 : _e.excludeTags.join(', ')}`);
        }
        if ((_f = this.config) === null || _f === void 0 ? void 0 : _f.includePaths) {
            this.log(`includePaths: ${(_g = this.config) === null || _g === void 0 ? void 0 : _g.includePaths.join(', ')}`);
        }
        if ((_h = this.config) === null || _h === void 0 ? void 0 : _h.excludePaths) {
            this.log(`excludePaths: ${(_j = this.config) === null || _j === void 0 ? void 0 : _j.excludePaths.join(', ')}`);
        }
    }
    /**
     * æ ¡éªŒè§„åˆ™
     * @param regexp æ­£åˆ™æ•°ç»„
     * @param data æ•°æ®
     */
    validateRegexp(data, regexp) {
        // ç¡®ä¿ data æ˜¯æ•°ç»„
        const dataArray = Array.isArray(data) ? data : [data];
        this.log(`"Data Array:", ${dataArray.join(',')}`);
        this.log(`"Regexp Array:", ${regexp.join(',')}`);
        return dataArray.some((item) => {
            const result = regexp.some((reg) => this.matches(item, reg));
            this.log(`"Item:", ${item}, "Matches:", ${result}`);
            return result;
        });
    }
    /**
     *
     * @param item æ•°ç»„æ•°æ®
     * @param reg è§„åˆ™
     */
    // æå–åŒ¹é…é€»è¾‘åˆ°å•ç‹¬çš„å‡½æ•°
    matches(item, reg) {
        if (typeof reg === 'string') {
            return (0, minimatch_1.minimatch)(item, reg, {
                nocase: this.config.filterCaseInsensitive,
            });
        }
        else if (reg instanceof RegExp) {
            reg.lastIndex = 0; // é‡ç½®æ­£åˆ™è¡¨è¾¾å¼çš„ lastIndex å±žæ€§
            return reg.test(item);
        }
        return false; // å¯¹äºŽå…¶ä»–ç±»åž‹ï¼Œè¿”å›ž false
    }
}
exports.default = ServiceGenerator;
