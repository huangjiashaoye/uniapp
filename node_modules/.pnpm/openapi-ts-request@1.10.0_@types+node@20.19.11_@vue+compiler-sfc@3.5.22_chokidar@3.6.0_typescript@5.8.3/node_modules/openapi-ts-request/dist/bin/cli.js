#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const prompts_1 = require("@clack/prompts");
const commander_1 = require("commander");
const index_1 = require("../index");
const log_1 = require("../log");
const readConfig_1 = require("../readConfig");
commander_1.program
    .option('-cfn, --configFileName <string>', 'config file name')
    .option('-cfp, --configFilePath <string>', 'config file path')
    .option('-u, --uniqueKey <string>', 'unique key');
commander_1.program.parse();
const options = commander_1.program.opts();
/**
 * 1. æ‰§è¡Œ cli å‘½ä»¤è¯»å–é…ç½®æ–‡ä»¶ï¼Œå·²ç»ä½¿ç”¨ openapi.ts æ›¿ä»£äº† cli.tsï¼ŒåŽæœŸä¼šåºŸå¼ƒ cli.ts
 * 2. å¦‚æžœé…ç½®æ–‡ä»¶ä¸­æœ‰ uniqueKeyï¼Œåˆ™æ ¹æ® uniqueKey ç”Ÿæˆ service
 * 3. å¦‚æžœé…ç½®æ–‡ä»¶ä¸­æ²¡æœ‰ uniqueKeyï¼Œä¸”æœ‰å¤šä¸ª serviceï¼Œåˆ™äº¤äº’å¼é€‰æ‹©è¦ç”Ÿæˆçš„ service
 */
function run() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const config = yield (0, readConfig_1.readConfig)({
            fallbackName: 'openapi-ts-request',
            filePath: options.filePath,
            fileName: options.fileName,
        });
        try {
            const tasks = [];
            if (config) {
                let configs = Array.isArray(config)
                    ? config
                    : [config];
                /** æ˜¯å¦äº¤äº’å¼ */
                let isInteractive = false;
                if (options.uniqueKey) {
                    configs = configs.filter((config) => config.uniqueKey === options.uniqueKey);
                }
                else if (configs.length > 1) {
                    // å¦‚æžœæ²¡æœ‰æŒ‡å®š uniqueKeyï¼Œå¹¶ä¸”æœ‰å¤šä¸ªé…ç½®ï¼Œåˆ™äº¤äº’å¼é€‰æ‹©
                    isInteractive = true;
                    console.log(''); // æ·»åŠ ä¸€ä¸ªç©ºè¡Œ
                    (0, prompts_1.intro)('ðŸŽ‰ æ¬¢è¿Žä½¿ç”¨ openapi-ts-request ç”Ÿæˆå™¨');
                    const selected = yield (0, prompts_1.multiselect)({
                        message: 'è¯·é€‰æ‹©è¦ç”Ÿæˆçš„ service',
                        options: configs.map((config) => ({
                            value: config,
                            label: config.describe || config.schemaPath,
                        })),
                    });
                    if ((0, prompts_1.isCancel)(selected)) {
                        (0, prompts_1.cancel)('ðŸ‘‹ Has cancelled');
                        process.exit(0);
                    }
                    configs = selected;
                }
                for (const config of configs) {
                    tasks.push((0, index_1.generateService)(config));
                }
                const results = yield Promise.allSettled(tasks);
                let errorMsg = '';
                for (let i = 0; i < results.length; i++) {
                    const result = results[i];
                    if (result.status === 'rejected') {
                        const cnf = configs[i];
                        errorMsg += `${cnf.uniqueKey}${cnf.uniqueKey && ':'}${result.reason}\n`;
                    }
                }
                if (errorMsg) {
                    throw new Error(errorMsg);
                }
                if (isInteractive && !errorMsg) {
                    (0, prompts_1.outro)('ðŸŽ‰ All done!');
                }
            }
            else {
                throw new Error('config is not found');
            }
        }
        catch (error) {
            (0, log_1.logError)(error);
            process.exit(1);
        }
    });
}
void run();
