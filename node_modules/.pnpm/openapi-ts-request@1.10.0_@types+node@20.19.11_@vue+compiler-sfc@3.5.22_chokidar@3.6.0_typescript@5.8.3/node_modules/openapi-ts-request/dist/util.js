"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.camelCase = exports.getOpenAPIConfig = exports.getOpenAPIConfigByApifox = exports.getImportStatement = void 0;
exports.parseSwaggerOrOpenapi = parseSwaggerOrOpenapi;
exports.translateChineseModuleNodeToEnglish = translateChineseModuleNodeToEnglish;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const bing_translate_api_1 = require("bing-translate-api");
const http_1 = tslib_1.__importDefault(require("http"));
const https_1 = tslib_1.__importDefault(require("https"));
const yaml = tslib_1.__importStar(require("js-yaml"));
const lodash_1 = require("lodash");
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const swagger2openapi_1 = tslib_1.__importDefault(require("swagger2openapi"));
const log_1 = tslib_1.__importStar(require("./log"));
const getImportStatement = (requestLibPath) => {
    if (requestLibPath) {
        if (requestLibPath.startsWith('import')) {
            return requestLibPath;
        }
        return `import request from '${requestLibPath}';`;
    }
    return `import request from 'axios';`;
};
exports.getImportStatement = getImportStatement;
/**
 * é€šè¿‡ apifox èŽ·å– openapi æ–‡æ¡£
 * @param params {object}
 * @param params.projectId {string} é¡¹ç›® id
 * @param params.locale {string} è¯­è¨€
 * @param params.apifoxVersion {string} apifox ç‰ˆæœ¬ ç›®å‰å›ºå®šä¸º 2024-03-28 å¯é€šè¿‡ https://api.apifox.com/v1/versions èŽ·å–æœ€æ–°ç‰ˆæœ¬
 * @returns
 */
const getSchemaByApifox = (_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ projectId, locale = 'zh-CN', apifoxVersion = '2024-03-28', selectedTags, excludedByTags = [], apifoxToken, oasVersion = '3.0', exportFormat = 'JSON', includeApifoxExtensionProperties = false, addFoldersToTags = false, }) {
    try {
        const body = {
            scope: {
                excludedByTags,
            },
            options: {
                includeApifoxExtensionProperties,
                addFoldersToTags,
            },
            oasVersion,
            exportFormat,
        };
        const tags = !(0, lodash_1.isEmpty)(selectedTags) ? selectedTags : '*';
        if (tags === '*') {
            body.scope.type = 'ALL';
        }
        else {
            body.scope.type = 'SELECTED_TAGS';
            body.scope.selectedTags = tags;
        }
        const res = yield axios_1.default.post(`https://api.apifox.com/v1/projects/${projectId}/export-openapi?locale=${locale}`, body, {
            headers: {
                'X-Apifox-Api-Version': apifoxVersion,
                Authorization: `Bearer ${apifoxToken}`,
            },
        });
        return res.data;
    }
    catch (error) {
        (0, log_1.logError)('fetch openapi error:', error);
        return null;
    }
});
function getSchema(schemaPath, authorization, timeout) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (schemaPath.startsWith('http')) {
            const isHttps = schemaPath.startsWith('https:');
            const protocol = isHttps ? https_1.default : http_1.default;
            try {
                const agent = new protocol.Agent({
                    rejectUnauthorized: false,
                });
                const config = isHttps ? { httpsAgent: agent } : { httpAgent: agent };
                const json = yield axios_1.default
                    .get(schemaPath, Object.assign(Object.assign({}, config), { headers: { authorization }, timeout }))
                    .then((res) => res.data);
                return json;
            }
            catch (error) {
                console.log('fetch openapi error:', error);
            }
            return;
        }
        if (require.cache[schemaPath]) {
            delete require.cache[schemaPath];
        }
        let schema = '';
        try {
            schema = (yield require(schemaPath));
        }
        catch (_a) {
            try {
                schema = (0, node_fs_1.readFileSync)(schemaPath, 'utf8');
            }
            catch (error) {
                console.error('Error reading schema file:', error);
            }
        }
        return schema;
    });
}
function converterSwaggerToOpenApi(swagger) {
    return new Promise((resolve, reject) => {
        const convertOptions = {
            patch: true,
            warnOnly: true,
            resolveInternal: true,
        };
        // options.patch = true; // fix up small errors in the source definition
        // options.warnOnly = true; // Do not throw on non-patchable errors
        // options.warnOnly = true; // enable resolution of internal $refs, also disables deduplication of requestBodies
        swagger2openapi_1.default.convertObj(swagger, convertOptions, (err, options) => {
            (0, log_1.default)(['ðŸ’º å°† Swagger è½¬åŒ–ä¸º openAPI']);
            if (err) {
                return reject(err);
            }
            resolve(options.openapi);
        });
    });
}
const getOpenAPIConfigByApifox = (props) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const schema = yield getSchemaByApifox(props);
    if (!schema) {
        return;
    }
    return yield parseSwaggerOrOpenapi(schema);
});
exports.getOpenAPIConfigByApifox = getOpenAPIConfigByApifox;
const getOpenAPIConfig = (schemaPath, authorization, timeout) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const schema = yield getSchema(schemaPath, authorization, timeout);
    if (!schema) {
        return;
    }
    const openAPI = yield parseSwaggerOrOpenapi(schema);
    return openAPI;
});
exports.getOpenAPIConfig = getOpenAPIConfig;
function parseSwaggerOrOpenapi(content) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let openapi = {};
        if ((0, lodash_1.isObject)(content)) {
            openapi = content;
            // if is swagger2.0 json, covert swagger2.0 to openapi3.0
            if (openapi.swagger) {
                openapi = yield converterSwaggerToOpenApi(openapi);
            }
        }
        else {
            if (isJSONString(content)) {
                openapi = JSON.parse(content);
            }
            else {
                openapi = yaml.load(content);
            }
            if (openapi.swagger) {
                openapi = yield converterSwaggerToOpenApi(openapi);
            }
        }
        return openapi;
    });
}
function isJSONString(str) {
    try {
        JSON.parse(str);
        return true;
    }
    catch (error) {
        return false;
    }
}
function readFileSafelySync(filePath) {
    if (!(0, node_fs_1.existsSync)(filePath)) {
        (0, log_1.logError)(`æ–‡ä»¶ ${filePath} ä¸å­˜åœ¨`);
        return null;
    }
    try {
        return (0, node_fs_1.readFileSync)(filePath, 'utf-8');
    }
    catch (error) {
        (0, log_1.logError)(`è¯»å–æ–‡ä»¶ ${filePath} æ—¶å‡ºé”™:`, error);
        return null;
    }
}
function writeFileAsync(filePath, content) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            yield (0, promises_1.writeFile)(filePath, content, 'utf8');
        }
        catch (error) {
            (0, log_1.logError)(`æ–‡ä»¶ ${filePath} å†™å…¥å¤±è´¥`);
        }
    });
}
function translateChineseModuleNodeToEnglish(openAPI) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const content = readFileSafelySync(process.cwd() + '/openapi-ts-request.cache.json');
        let i18n = {};
        if (content !== null) {
            if (isJSONString(content)) {
                i18n = JSON.parse(content);
            }
        }
        return new Promise((resolve, reject) => {
            const translateMap = i18n;
            const operations = [];
            let tags = [];
            (0, lodash_1.forEach)((0, lodash_1.keys)(openAPI.paths), (path) => {
                const pathItemObject = openAPI.paths[path];
                (0, lodash_1.forEach)((0, lodash_1.keys)(pathItemObject), (method) => {
                    if (pathItemObject[method]) {
                        const operation = pathItemObject[method];
                        operations.push(operation);
                        tags = tags.concat(operation.tags);
                    }
                });
            });
            void Promise.all((0, lodash_1.map)((0, lodash_1.uniq)(tags), (tagName) => {
                return new Promise((resolve) => {
                    if (tagName && /[\u3220-\uFA29]/.test(tagName) && !i18n[tagName]) {
                        void (0, bing_translate_api_1.translate)(tagName, null, 'en')
                            .then((translateRes) => {
                            const text = (0, exports.camelCase)(translateRes === null || translateRes === void 0 ? void 0 : translateRes.translation);
                            if (text) {
                                translateMap[tagName] = text;
                                resolve(text);
                            }
                        })
                            .catch(() => {
                            resolve(tagName);
                        });
                    }
                    else {
                        resolve(tagName);
                    }
                });
            }))
                .then(() => {
                (0, lodash_1.forEach)(operations, (operation) => {
                    (0, lodash_1.forEach)(operation.tags, (tagName, index) => {
                        if (translateMap[tagName]) {
                            operation.tags[index] = translateMap[tagName];
                        }
                    });
                });
                resolve(translateMap);
                void writeFileAsync(process.cwd() + '/openapi-ts-request.cache.json', JSON.stringify(translateMap, null, 2));
            })
                .catch(() => {
                reject(false);
            });
        });
    });
}
/**
 * Converts a string to camelCase format, with an option to capitalize the first letter.
 * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºé©¼å³°æ ¼å¼ï¼Œå¹¶å¯ä»¥é€‰æ‹©å°†é¦–å­—æ¯å¤§å†™ã€‚
 *
 * @param {string} str - The string to convert.
 * @param {string} str - è¦è½¬æ¢çš„å­—ç¬¦ä¸²ã€‚
 *
 * @param {boolean} [upper=false] - Whether to capitalize the first letter of the resulting string.
 * @param {boolean} [upper=false] - æ˜¯å¦å°†ç»“æžœå­—ç¬¦ä¸²çš„é¦–å­—æ¯å¤§å†™ã€‚
 *
 * @returns {string} The camelCase formatted string, optionally with a capitalized first letter.
 * @returns {string} è¿”å›žé©¼å³°æ ¼å¼çš„å­—ç¬¦ä¸²ï¼Œå¯é€‰æ‹©é¦–å­—æ¯å¤§å†™ã€‚
 */
const camelCase = (str, upper = false) => {
    const res = (0, lodash_1.camelCase)(str);
    return upper ? res.charAt(0).toUpperCase() + res.slice(1) : res;
};
exports.camelCase = camelCase;
