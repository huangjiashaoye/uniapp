import path, { join, dirname, resolve, extname } from 'node:path';
import process from 'node:process';
import { babelParse, isCallOf } from 'ast-kit';
import chokidar from 'chokidar';
import { lightYellow, bold, link, dim } from 'kolorist';
import MagicString from 'magic-string';
import { normalizePath, createLogger } from 'vite';
import fs, { existsSync } from 'node:fs';
import { platform } from '@uni-helper/uni-env';
import { parse, assign, stringify, CommentArray } from 'comment-json';
import Debug from 'debug';
import detectIndent from 'detect-indent';
import detectNewline from 'detect-newline';
import { loadConfig } from 'unconfig';
import { readFile, mkdir, writeFile as writeFile$1 } from 'node:fs/promises';
import fg from 'fast-glob';
import lockfile from 'proper-lockfile';
import { createRequire } from 'node:module';
import vm from 'node:vm';
import babelGenerator from '@babel/generator';
import groupBy from 'lodash.groupby';
import * as ts from 'typescript';
import * as t from '@babel/types';
import { parse as parse$2 } from '@vue/compiler-sfc';
import JSON5 from 'json5';
import { parse as parse$1 } from 'yaml';

const MODULE_ID_VIRTUAL = "virtual:uni-pages";
const RESOLVED_MODULE_ID_VIRTUAL = `\0${MODULE_ID_VIRTUAL}`;
const OUTPUT_NAME = "pages.json";
const FILE_EXTENSIONS = ["vue", "nvue", "uvue"];

function slash(str) {
  return str.replace(/\\/g, "/");
}

function getDeclaration(ctx) {
  const subPagesPath = ctx.subPageMetaData.map((sub) => {
    return sub.pages.map((v) => `"/${normalizePath(join(sub.root, v.path))}"`);
  }).flat();
  const tabsPagesPath = ctx.pagesGlobConfig?.tabBar?.list?.map((v) => {
    return `"/${v.pagePath}"`;
  }) ?? [];
  const allPagesPath = [...ctx.pageMetaData.filter((page) => !tabsPagesPath.includes(page.path)).map((v) => `"/${v.path}"`), ...subPagesPath];
  const code = `/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// Generated by vite-plugin-uni-pages

type _LocationUrl =
  ${allPagesPath.join(" |\n  ")};

interface NavigateToOptions {
  url: _LocationUrl;
}
interface RedirectToOptions extends NavigateToOptions {}

interface SwitchTabOptions {
  ${tabsPagesPath.length ? `url: ${tabsPagesPath.join(" | ")}` : ""}
}

type ReLaunchOptions = NavigateToOptions | SwitchTabOptions;

declare interface Uni {
  navigateTo(options: UniNamespace.NavigateToOptions & NavigateToOptions): void;
  redirectTo(options: UniNamespace.RedirectToOptions & RedirectToOptions): void;
  switchTab(options: UniNamespace.SwitchTabOptions & SwitchTabOptions): void;
  reLaunch(options: UniNamespace.ReLaunchOptions & ReLaunchOptions): void;
}

declare module "virtual:uni-pages" {
  export type LocationUrl = _LocationUrl;
}
`;
  return code;
}
async function writeFile(filePath, content) {
  await mkdir(dirname(filePath), { recursive: true });
  return await writeFile$1(filePath, content, "utf-8");
}
async function writeDeclaration(ctx, filepath) {
  const originalContent = existsSync(filepath) ? await readFile(filepath, "utf-8") : "";
  const code = getDeclaration(ctx);
  if (!code)
    return;
  if (code !== originalContent)
    await writeFile(filepath, code);
}

function invalidatePagesModule(server) {
  const { moduleGraph } = server;
  const mods = moduleGraph.getModulesByFile(RESOLVED_MODULE_ID_VIRTUAL);
  if (mods) {
    const seen = /* @__PURE__ */ new Set();
    mods.forEach((mod) => {
      moduleGraph.invalidateModule(mod, seen);
    });
  }
}
const debug = {
  hmr: Debug("vite-plugin-uni-pages:hmr"),
  routeBlock: Debug("vite-plugin-uni-pages:routeBlock"),
  options: Debug("vite-plugin-uni-pages:options"),
  pages: Debug("vite-plugin-uni-pages:pages"),
  subPages: Debug("vite-plugin-uni-pages:subPages"),
  error: Debug("vite-plugin-uni-pages:error"),
  cache: Debug("vite-plugin-uni-pages:cache"),
  declaration: Debug("vite-plugin-uni-pages:declaration"),
  definePage: Debug("vite-plugin-uni-pages:definePage")
};
function extsToGlob(extensions) {
  return extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0] || "";
}
function isTargetFile(path2) {
  const ext = path2.split(".").pop();
  return FILE_EXTENSIONS.includes(ext);
}
function mergePageMetaDataArray(pageMetaData) {
  const pageMetaDataObj = groupBy(pageMetaData, "path");
  const result = [];
  for (const path2 in pageMetaDataObj) {
    const _pageMetaData = pageMetaDataObj[path2];
    const options = _pageMetaData[0];
    for (const page of _pageMetaData) {
      options.style = Object.assign(options.style ?? {}, page.style ?? {});
      Object.assign(options, page);
    }
    result.push(options);
  }
  return result;
}
async function parseCode(options) {
  const { imports = [], code, filename } = options;
  let jsCode = "";
  try {
    const tmpCode = `${imports.join("\n")}
 export default ${code}`;
    jsCode = ts.transpileModule(tmpCode, {
      compilerOptions: {
        module: ts.ModuleKind.CommonJS,
        // 生成的模块格式为 CommonJS（Node.js 默认格式）
        target: ts.ScriptTarget.ES2022,
        // 编译后的 JavaScript 目标版本
        noEmit: true,
        // 不生成输出文件
        strict: false,
        // 关闭所有严格类型检查选项
        noImplicitAny: false,
        // 允许表达式和 any 类型
        strictNullChecks: false,
        // 关闭严格的 null 和 undefined 检查
        strictFunctionTypes: false,
        // 关闭函数参数的严格逆变比较
        strictBindCallApply: false,
        // 关闭对 bind、call 和 apply 方法的严格类型检查
        strictPropertyInitialization: false,
        // 关闭类属性初始化的严格检查
        noImplicitThis: false,
        // 允许 this 表达式具有隐式的 any 类型
        alwaysStrict: false,
        // 不以严格模式解析并为每个源文件生成 "use strict" 指令
        allowJs: true,
        // 允许编译 JavaScript 文件
        checkJs: false,
        // 不检查 JavaScript 文件中的类型
        skipLibCheck: true,
        // 跳过对 TypeScript 声明文件 (*.d.ts) 的类型检查
        esModuleInterop: true,
        // 启用 ES 模块互操作性，允许使用 import 导入 CommonJS 模块
        removeComments: true
        // 删除注释
      },
      jsDocParsingMode: ts.JSDocParsingMode.ParseNone
      // 不解析 JSDoc
    }).outputText;
    const dir = path.dirname(filename);
    const vmContext = {
      module: {},
      exports: {},
      __filename: filename,
      __dirname: dir,
      require: createRequire(dir),
      import: (id) => import(id),
      // 定时器相关
      setTimeout,
      clearTimeout,
      setInterval,
      clearInterval,
      setImmediate,
      clearImmediate,
      // 控制台相关
      console,
      // URL 处理
      URL,
      URLSearchParams,
      // 进程和性能相关
      performance,
      // 全局对象引用
      global: globalThis,
      globalThis
    };
    const script = new vm.Script(jsCode, { filename });
    await script.runInNewContext(vmContext, {
      timeout: 1e3
      // 设置超时避免长时间运行
    });
    const result = vmContext.exports.default || vmContext.exports;
    return result;
  } catch (error) {
    throw new Error(`EXEC SCRIPT FAIL IN ${filename}: ${error.message} 

${jsCode}

`);
  }
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function getDefaultExport(expr) {
  return expr.default === void 0 ? expr : expr.default;
}
const babelGenerate = getDefaultExport(babelGenerator);

function getPageFiles(path, options) {
  const { exclude } = options;
  const ext = extsToGlob(FILE_EXTENSIONS);
  const files = fg.sync(`**/*.${ext}`, {
    ignore: exclude,
    onlyFiles: true,
    cwd: path
  });
  return files;
}
function checkPagesJsonFileSync(path) {
  const createEmptyFile = (path2) => {
    try {
      fs.writeFileSync(
        path2,
        JSON.stringify({ pages: [{ path: "" }] }, null, 2),
        { encoding: "utf-8" }
      );
      return true;
    } catch {
      return false;
    }
  };
  const unlinkFile = (path2) => {
    try {
      fs.unlinkSync(path2);
      return true;
    } catch {
      return false;
    }
  };
  try {
    try {
      fs.accessSync(path, fs.constants.F_OK);
    } catch {
      return createEmptyFile(path);
    }
    const stat = fs.statSync(path);
    if (!stat.isFile()) {
      if (!unlinkFile(path)) {
        return false;
      }
      return createEmptyFile(path);
    }
    try {
      fs.accessSync(path, fs.constants.R_OK | fs.constants.W_OK);
      return true;
    } catch {
      if (!unlinkFile(path)) {
        return false;
      }
      return createEmptyFile(path);
    }
  } catch {
    return createEmptyFile(path);
  }
}
async function writeFileWithLock(path, content, retry = 3) {
  if (retry <= 0) {
    debug.error(`${path} \u83B7\u53D6\u6587\u4EF6\u9501\u5931\u8D25\uFF0C\u5199\u5165\u5931\u8D25`);
    return;
  }
  let release;
  try {
    try {
      release = await lockfile.lock(path, { realpath: false });
    } catch {
      await sleep(500);
      return writeFileWithLock(path, content, retry - 1);
    }
    await fs.promises.writeFile(path, content, { encoding: "utf-8" });
  } finally {
    if (release) {
      await release();
    }
  }
}

function resolveOptions(userOptions, viteRoot = process.cwd()) {
  const {
    dts = true,
    configSource = "pages.config",
    homePage = ["pages/index", "pages/index/index"],
    mergePages = true,
    dir = "src/pages",
    subPackages = [],
    outDir = "src",
    exclude = ["node_modules", ".git", "**/__*__/**"],
    routeBlockLang = "json5",
    minify = false,
    debug = false,
    onBeforeLoadUserConfig = () => {
    },
    onAfterLoadUserConfig = () => {
    },
    onBeforeScanPages = () => {
    },
    onAfterScanPages = () => {
    },
    onBeforeMergePageMetaData = () => {
    },
    onAfterMergePageMetaData = () => {
    },
    onBeforeWriteFile = () => {
    },
    onAfterWriteFile = () => {
    }
  } = userOptions;
  const root = viteRoot || slash(process.env.VITE_ROOT_DIR || process.cwd());
  const resolvedDirs = resolvePageDirs(dir, root, exclude);
  const resolvedSubDirs = subPackages.map((dir2) => slash(dir2));
  const resolvedHomePage = typeof homePage === "string" ? [homePage] : homePage;
  const resolvedConfigSource = typeof configSource === "string" ? [{ files: configSource }] : configSource;
  const resolvedDts = !dts ? false : typeof dts === "string" ? dts : resolve(viteRoot, "uni-pages.d.ts");
  const resolvedOptions = {
    dts: resolvedDts,
    configSource: Array.isArray(resolvedConfigSource) ? resolvedConfigSource : [resolvedConfigSource],
    homePage: resolvedHomePage,
    mergePages,
    dirs: resolvedDirs,
    subPackages: resolvedSubDirs,
    outDir,
    exclude,
    routeBlockLang,
    root,
    minify,
    debug,
    onBeforeLoadUserConfig,
    onAfterLoadUserConfig,
    onBeforeScanPages,
    onAfterScanPages,
    onBeforeMergePageMetaData,
    onAfterMergePageMetaData,
    onBeforeWriteFile,
    onAfterWriteFile
  };
  return resolvedOptions;
}
function resolvePageDirs(dir, root, exclude) {
  const dirs = fg.sync(slash(dir), {
    ignore: exclude,
    onlyDirectories: true,
    dot: true,
    unique: true,
    cwd: root
  });
  return dirs;
}

function parseCustomBlock(block, filePath, routeBlockLang) {
  const lang = block.lang ?? routeBlockLang;
  const attr = {
    type: "page",
    ...block.attrs
  };
  let content;
  debug.routeBlock(`use ${lang} parser`);
  if (lang === "json5") {
    try {
      content = JSON5.parse(block.content);
    } catch (err) {
      throw new Error(
        `Invalid JSON5 format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else if (lang === "jsonc") {
    try {
      content = parse(block.content);
    } catch (err) {
      throw new Error(
        `Invalid JSONC format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else if (lang === "json") {
    try {
      content = JSON.parse(block.content);
    } catch (err) {
      throw new Error(
        `Invalid JSON format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else if (lang === "yaml" || lang === "yml") {
    try {
      content = parse$1(block.content);
    } catch (err) {
      throw new Error(
        `Invalid YAML format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  }
  return {
    attr,
    content: content ?? {}
  };
}
function getRouteSfcBlock(sfc) {
  return sfc?.customBlocks.find((b) => b.type === "route");
}
function getRouteBlock(path, blockStr, routeBlockLang) {
  if (!blockStr)
    return;
  return parseCustomBlock(blockStr, path, routeBlockLang);
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Page {
  constructor(ctx, path) {
    __publicField$1(this, "ctx");
    __publicField$1(this, "path");
    __publicField$1(this, "uri");
    __publicField$1(this, "changed", true);
    __publicField$1(this, "raw", "");
    __publicField$1(this, "meta");
    this.ctx = ctx;
    this.path = path;
    this.uri = normalizePath(path.relativePath.replace(extname(path.relativePath), ""));
  }
  async getPageMeta(forceUpdate = false) {
    if (forceUpdate || !this.meta) {
      await this.read();
    }
    const { path, tabBar: _, ...others } = this.meta || {};
    return {
      path: path ?? this.uri,
      ...others
    };
  }
  async getTabBar(forceUpdate = false) {
    if (forceUpdate || !this.meta) {
      await this.read();
    }
    const { tabBar } = this.meta;
    if (tabBar === void 0) {
      return void 0;
    }
    return {
      ...tabBar,
      pagePath: tabBar.pagePath || this.uri,
      index: tabBar.index || 0
    };
  }
  hasChanged() {
    return this.changed;
  }
  async read() {
    let meta;
    try {
      meta = await this.readPageMetaFromFile();
    } catch (err) {
      debug.error(err);
      return;
    }
    let raw = "";
    try {
      raw = JSON.stringify(meta);
    } catch {
    }
    this.changed = this.raw !== raw;
    this.meta = meta;
    this.raw = raw;
  }
  async readPageMetaFromFile() {
    try {
      const content = await fs.promises.readFile(this.path.absolutePath, { encoding: "utf-8" });
      const sfc = parseSFC(content, { filename: this.path.absolutePath });
      const meta = await tryPageMetaFromMacro(sfc);
      if (meta) {
        return meta;
      }
      return tryPageMetaFromCustomBlock(sfc, this.ctx.options.routeBlockLang);
    } catch (err) {
      throw new Error(`Read page meta fail in ${this.path.relativePath}
${err.message}`);
    }
  }
}
function parseSFC(code, options) {
  return parse$2(code, {
    pad: "space",
    ...options
  }).descriptor || parse$2({
    source: code,
    ...options
  });
}
async function tryPageMetaFromMacro(sfc) {
  const sfcScript = sfc.scriptSetup || sfc.script;
  if (!sfcScript) {
    return void 0;
  }
  const ast = babelParse(sfcScript.content, sfcScript.lang || "js", {
    plugins: [["importAttributes", { deprecatedAssertSyntax: true }]]
  });
  const macro = findMacro(ast.body, sfc.filename);
  if (macro) {
    const imports = findImports(ast.body).filter((imp) => !!imp.specifiers.length).map((imp) => babelGenerate(imp).code);
    const [macroOption] = macro.arguments;
    const code = babelGenerate(macroOption).code;
    const parsed = await parseCode({
      imports,
      code,
      filename: sfc.filename
    });
    const res = typeof parsed === "function" ? await Promise.resolve(parsed()) : await Promise.resolve(parsed);
    return {
      type: "page",
      ...res
    };
  }
  return void 0;
}
async function tryPageMetaFromCustomBlock(sfc, routeBlockLang) {
  const block = getRouteSfcBlock(sfc);
  const routeBlock = getRouteBlock(sfc.filename, block, routeBlockLang);
  const pageMeta = {
    type: routeBlock?.attr.type ?? "page"
  };
  if (routeBlock) {
    try {
      assign(pageMeta, routeBlock.content);
    } catch {
    }
  }
  return pageMeta;
}
function findMacro(stmts, filename) {
  let macro;
  for (const stmt of stmts) {
    let node = stmt;
    if (stmt.type === "ExpressionStatement")
      node = stmt.expression;
    if (isCallOf(node, "definePage")) {
      macro = node;
      break;
    }
  }
  if (!macro)
    return;
  const [opt] = macro.arguments;
  if (opt && !t.isFunctionExpression(opt) && !t.isArrowFunctionExpression(opt) && !t.isObjectExpression(opt)) {
    debug.definePage(`definePage() \u53C2\u6570\u4EC5\u652F\u6301\u51FD\u6570\u6216\u5BF9\u8C61\uFF1A${filename}`);
    return;
  }
  return macro;
}
function findImports(stmts) {
  const imports = [];
  for (const stmt of stmts) {
    if (t.isImportDeclaration(stmt)) {
      imports.push(stmt);
    }
  }
  return imports;
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class PageContext {
  constructor(userOptions, viteRoot = process.cwd()) {
    __publicField(this, "_server");
    __publicField(this, "pagesGlobConfig");
    __publicField(this, "pagesConfigSourcePaths", []);
    __publicField(this, "pages", /* @__PURE__ */ new Map());
    // abs path -> Page
    __publicField(this, "subPages", /* @__PURE__ */ new Map());
    // root -> abs path -> page
    __publicField(this, "pageMetaData", []);
    __publicField(this, "subPageMetaData", []);
    __publicField(this, "resolvedPagesJSONPath", "");
    __publicField(this, "resolvedPagesJSONIndent");
    // '  '
    __publicField(this, "resolvedPagesJSONNewline");
    // '\n'
    __publicField(this, "resolvedPagesJSONEofNewline");
    // true
    __publicField(this, "rawOptions");
    __publicField(this, "root");
    __publicField(this, "options");
    __publicField(this, "logger");
    __publicField(this, "withUniPlatform", false);
    __publicField(this, "lastPagesJson", "");
    this.rawOptions = userOptions;
    this.root = slash(viteRoot);
    debug.options("root", this.root);
    this.options = resolveOptions(userOptions, this.root);
    const debugOption = this.options.debug;
    if (debugOption) {
      const prefix = "vite-plugin-uni-pages:";
      const suffix = typeof debugOption === "boolean" ? "*" : debugOption;
      Debug.enable(`${prefix}${suffix}`);
    }
    this.resolvedPagesJSONPath = path.join(this.root, this.options.outDir, OUTPUT_NAME);
    debug.options(this.options);
  }
  setLogger(logger) {
    this.logger = logger;
  }
  async loadUserPagesConfig() {
    const configSource = this.options.configSource;
    const { config, sources } = await loadConfig({ cwd: this.root, sources: configSource, defaults: {} });
    this.pagesGlobConfig = config.default || config;
    this.pagesConfigSourcePaths = sources;
    debug.options(this.pagesGlobConfig);
  }
  async scanPages() {
    const pageDirFiles = this.options.dirs.map((dir) => {
      return { dir, files: getPagePaths(dir, this.options) };
    });
    const paths = pageDirFiles.map((page) => page.files).flat();
    debug.pages(paths);
    const pages = /* @__PURE__ */ new Map();
    for (const path2 of paths) {
      const page = this.pages.get(path2.absolutePath) || new Page(this, path2);
      pages.set(path2.absolutePath, page);
    }
    this.pages = pages;
  }
  async scanSubPages() {
    const paths = {};
    const subPages = /* @__PURE__ */ new Map();
    for (const dir of this.options.subPackages) {
      const pagePaths = getPagePaths(dir, this.options);
      paths[dir] = pagePaths;
      const pages = /* @__PURE__ */ new Map();
      for (const path2 of pagePaths) {
        const page = this.subPages.get(dir)?.get(path2.absolutePath) || new Page(this, path2);
        pages.set(path2.absolutePath, page);
      }
      subPages.set(dir, pages);
    }
    debug.subPages(JSON.stringify(paths, null, 2));
    this.subPages = subPages;
  }
  setupViteServer(server) {
    if (this._server === server)
      return;
    this._server = server;
    this.setupWatcher(server.watcher);
  }
  async setupWatcher(watcher) {
    watcher.add(this.pagesConfigSourcePaths);
    const targetDirs = [...this.options.dirs, ...this.options.subPackages].map((v) => slash(path.resolve(this.root, v)));
    const isInTargetDirs = (filePath) => targetDirs.some((v) => slash(path.resolve(this.root, filePath)).startsWith(v));
    watcher.on("add", async (path2) => {
      path2 = slash(path2);
      if (!isTargetFile(path2))
        return;
      if (!isInTargetDirs(path2))
        return;
      debug.pages(`File added: ${path2}`);
      if (await this.updatePagesJSON())
        this.onUpdate();
    });
    watcher.on("change", async (path2) => {
      path2 = slash(path2);
      if (!isTargetFile(path2))
        return;
      if (!isInTargetDirs(path2))
        return;
      debug.pages(`File changed: ${path2}`);
      debug.pages(targetDirs);
      debug.pages(isInTargetDirs(path2));
      if (await this.updatePagesJSON(path2))
        this.onUpdate();
    });
    watcher.on("change", async (path2) => {
      if (this.pagesConfigSourcePaths.includes(path2)) {
        debug.pages(`Config source changed: ${path2}`);
        if (await this.updatePagesJSON())
          this.onUpdate();
      }
    });
    watcher.on("unlink", async (path2) => {
      path2 = slash(path2);
      if (!isTargetFile(path2))
        return;
      if (!isInTargetDirs(path2))
        return;
      debug.pages(`File removed: ${path2}`);
      if (await this.updatePagesJSON())
        this.onUpdate();
    });
  }
  onUpdate() {
    if (!this._server)
      return;
    invalidatePagesModule(this._server);
    debug.hmr("Reload generated pages.");
    this._server.ws.send({
      type: "full-reload"
    });
  }
  /**
   * parse pages rules && set page type
   * @param pages page path array
   * @param type  page type
   * @param overrides custom page config
   * @returns pages rules
   */
  async parsePages(pages, type, overrides) {
    const jobs = [];
    for (const [_, page] of pages) {
      jobs.push(page.getPageMeta());
    }
    const generatedPageMetaData = await Promise.all(jobs);
    const customPageMetaData = overrides || [];
    const result = customPageMetaData.length ? mergePageMetaDataArray(generatedPageMetaData.concat(customPageMetaData)) : generatedPageMetaData;
    const parseMeta = Array.from(
      result.reduce((map, page) => {
        map.set(page.path, page);
        return map;
      }, /* @__PURE__ */ new Map()).values()
    );
    return type === "main" ? this.setHomePage(parseMeta) : parseMeta;
  }
  /**
   * set home page
   * @param result pages rules array
   * @returns pages rules
   */
  setHomePage(result) {
    const hasHome = result.some(({ type }) => type === "home");
    if (!hasHome) {
      const isFoundHome = result.some((item) => {
        const isFound = this.options.homePage.find((v) => v === item.path);
        if (isFound)
          item.type = "home";
        return isFound;
      });
      if (!isFoundHome) {
        this.logger?.warn('No home page found, check the configuration of pages.config.ts, or add the `homePage` option to UniPages in vite.config.js, or add `type="home"` to the routeBlock of your vue page.', {
          timestamp: true
        });
      }
    }
    result.sort((page) => page.type === "home" ? -1 : 0);
    return result;
  }
  async mergePageMetaData() {
    const subPageAbsolutePaths = Array.from(this.subPages.values()).flatMap((v) => Array.from(v.keys()));
    for (const subPageAbsolutePath of subPageAbsolutePaths)
      this.pages.delete(subPageAbsolutePath);
    const pageMetaData = await this.parsePages(this.pages, "main", this.pagesGlobConfig?.pages);
    this.pageMetaData = pageMetaData;
    debug.pages(this.pageMetaData);
  }
  async mergeSubPageMetaData() {
    const subPageMaps = {};
    const subPackages = this.pagesGlobConfig?.subPackages || [];
    for (const [dir, pages] of this.subPages) {
      const basePath = slash(path.join(this.options.root, this.options.outDir));
      const root = slash(path.relative(basePath, path.join(this.options.root, dir)));
      const globPackage = subPackages?.find((v) => v.root === root);
      subPageMaps[root] = await this.parsePages(pages, "sub", globPackage?.pages);
      subPageMaps[root] = subPageMaps[root].map((page) => ({ ...page, path: slash(path.relative(root, page.path)) }));
    }
    for (const { root, pages } of subPackages) {
      if (root && !subPageMaps[root])
        subPageMaps[root] = pages || [];
    }
    const subPageMetaData = Object.keys(subPageMaps).map((root) => ({ root, pages: subPageMaps[root] })).filter((meta) => meta.pages.length > 0);
    this.subPageMetaData = subPageMetaData;
    debug.subPages(this.subPageMetaData);
  }
  async getTabBarMerged() {
    const tabBarItems = [];
    for (const [_, page] of this.pages) {
      const tabbar = await page.getTabBar();
      if (tabbar) {
        tabBarItems.push(tabbar);
      }
    }
    if (tabBarItems.length === 0) {
      return this.pagesGlobConfig?.tabBar;
    }
    const tabBar = {
      ...this.pagesGlobConfig?.tabBar,
      list: this.pagesGlobConfig?.tabBar?.list || []
    };
    const pagePaths = /* @__PURE__ */ new Map();
    for (const item of tabBar.list) {
      pagePaths.set(item.pagePath, true);
    }
    tabBarItems.sort((a, b) => a.index - b.index);
    for (const item of tabBarItems) {
      if (!pagePaths.has(item.pagePath)) {
        const { index: _, ...tabbar } = item;
        tabBar.list.push(tabbar);
      }
    }
    return tabBar;
  }
  async updatePagesJSON(filepath) {
    if (filepath) {
      let page = this.pages.get(filepath);
      if (!page) {
        let subPage;
        for (const [_, pages2] of this.subPages) {
          subPage = pages2.get(filepath);
          if (subPage) {
            break;
          }
        }
        page = subPage;
      }
      if (page) {
        await page.read();
        if (!page.hasChanged()) {
          debug.cache(`The route block on page ${filepath} did not send any changes, skipping`);
          return false;
        }
      }
    }
    checkPagesJsonFileSync(this.resolvedPagesJSONPath);
    this.options.onBeforeLoadUserConfig(this);
    await this.loadUserPagesConfig();
    this.options.onAfterLoadUserConfig(this);
    if (this.options.mergePages) {
      this.options.onBeforeScanPages(this);
      await this.scanPages();
      await this.scanSubPages();
      this.options.onAfterScanPages(this);
    }
    this.options.onBeforeMergePageMetaData(this);
    await this.mergePageMetaData();
    await this.mergeSubPageMetaData();
    this.options.onAfterMergePageMetaData(this);
    const pagesMap = /* @__PURE__ */ new Map();
    const pages = this.withUniPlatform ? this.pageMetaData.filter((v) => !/\..*$/.test(v.path) || v.path.includes(platform)).map((v) => {
      v.path = v.path.replace(/\..*$/, "");
      return v;
    }) : this.pageMetaData;
    pages.forEach((v) => pagesMap.set(v.path, v));
    this.pageMetaData = [...pagesMap.values()];
    this.options.onBeforeWriteFile(this);
    const data = await this.genratePagesJSON();
    const pagesJson = stringify(
      data,
      null,
      this.options.minify ? void 0 : await this.getIndent()
    ) + (await this.getEndOfLine() ? await this.getNewline() : "");
    this.generateDeclaration();
    if (this.lastPagesJson === pagesJson) {
      debug.pages("PagesJson Not have change");
      return false;
    }
    await writeFileWithLock(this.resolvedPagesJSONPath, pagesJson);
    this.lastPagesJson = pagesJson;
    this.options.onAfterWriteFile(this);
    return true;
  }
  virtualModule() {
    const pages = `export const pages = ${this.resolveRoutes()};`;
    const subPackages = `export const subPackages = ${this.resolveSubRoutes()};`;
    return [pages, subPackages].join("\n");
  }
  resolveRoutes() {
    return stringify(this.pageMetaData, null, 2);
  }
  resolveSubRoutes() {
    return stringify(this.subPageMetaData, null, 2);
  }
  generateDeclaration() {
    if (!this.options.dts)
      return;
    debug.declaration("generating");
    return writeDeclaration(this, this.options.dts);
  }
  async genratePagesJSON() {
    const content = await fs.promises.readFile(this.resolvedPagesJSONPath, { encoding: "utf-8" }).catch(() => "");
    const { pages: oldPages, subPackages: oldSubPackages, tabBar: oldTabBar } = parse(content || "{}");
    const { pages: _, subPackages: __, tabBar: ___, ...pageJson } = this.pagesGlobConfig || {};
    const currentPlatform = platform.toUpperCase();
    pageJson.pages = mergePlatformItems(oldPages, currentPlatform, this.pageMetaData, "path");
    pageJson.subPackages = oldSubPackages || new CommentArray();
    const newSubPackages = /* @__PURE__ */ new Map();
    for (const item of this.subPageMetaData) {
      newSubPackages.set(item.root, item);
    }
    for (const existing of pageJson.subPackages) {
      const sub = newSubPackages.get(existing.root);
      if (sub) {
        existing.pages = mergePlatformItems(existing.pages, currentPlatform, sub.pages, "path");
        newSubPackages.delete(existing.root);
      }
    }
    for (const [_2, newSub] of newSubPackages) {
      pageJson.subPackages.push({
        root: newSub.root,
        pages: mergePlatformItems(void 0, currentPlatform, newSub.pages, "path")
      });
    }
    const { list, ...tabBarOthers } = await this.getTabBarMerged() || {};
    if (list) {
      const { list: oldList } = oldTabBar || {};
      const newList = mergePlatformItems(oldList, currentPlatform, list, "pagePath");
      pageJson.tabBar = {
        ...tabBarOthers,
        // 每次都直接更新除 list 外的其他属性
        list: newList
      };
    } else {
      pageJson.tabBar = void 0;
    }
    return pageJson;
  }
  async readInfoFromPagesJSON() {
    const resolvedPagesJSONContent = await fs.promises.readFile(this.resolvedPagesJSONPath, { encoding: "utf-8" }).catch(() => "");
    this.resolvedPagesJSONIndent = detectIndent(resolvedPagesJSONContent).indent || "  ";
    this.resolvedPagesJSONNewline = detectNewline(resolvedPagesJSONContent) || "\n";
    this.resolvedPagesJSONEofNewline = (resolvedPagesJSONContent.at(-1) ?? "\n") === this.resolvedPagesJSONNewline;
  }
  async getIndent() {
    if (!this.resolvedPagesJSONIndent) {
      await this.readInfoFromPagesJSON();
    }
    return this.resolvedPagesJSONIndent;
  }
  async getNewline() {
    if (!this.resolvedPagesJSONNewline) {
      await this.readInfoFromPagesJSON();
    }
    return this.resolvedPagesJSONNewline;
  }
  async getEndOfLine() {
    if (!this.resolvedPagesJSONEofNewline) {
      await this.readInfoFromPagesJSON();
    }
    return this.resolvedPagesJSONEofNewline;
  }
}
function getPagePaths(dir, options) {
  const pagesDirPath = slash(path.resolve(options.root, dir));
  const basePath = slash(path.join(options.root, options.outDir));
  const files = getPageFiles(pagesDirPath, options);
  debug.pages(dir, files);
  const pagePaths = files.map((file) => slash(file)).map((file) => ({
    relativePath: path.relative(basePath, slash(path.resolve(pagesDirPath, file))),
    absolutePath: slash(path.resolve(pagesDirPath, file))
  }));
  return pagePaths;
}
function mergePlatformItems(source, currentPlatform, items, uniqueKeyName) {
  const src = source || new CommentArray();
  currentPlatform = currentPlatform.toUpperCase();
  let lastPlatforms = [];
  for (const comment of src[Symbol.for("before:0")] || []) {
    const trimed = comment.value.trim();
    if (trimed.startsWith("GENERATED BY UNI-PAGES, PLATFORM:")) {
      lastPlatforms = trimed.split(":")[1].split("||").map((s) => s.trim()).filter((s) => s !== currentPlatform).sort();
    }
  }
  const tmpMap = /* @__PURE__ */ new Map();
  for (let i = 0; i < src.length; i++) {
    const item = src[i];
    const uniqueKey = item[uniqueKeyName];
    if (!uniqueKey) {
      continue;
    }
    const beforeComments = src[Symbol.for(`before:${i}`)];
    const ifdefComment = beforeComments?.find((c) => c.value.trim().startsWith("#ifdef"));
    let platforms = [...lastPlatforms];
    if (ifdefComment) {
      const match = ifdefComment.value.match(/#ifdef\s+(.+)/);
      if (match) {
        platforms = match[1].split("||").map((p) => p.trim()).filter((s) => s !== currentPlatform).sort();
      }
    }
    if (platforms.length === 0) {
      continue;
    }
    const existing = tmpMap.get(uniqueKey) || [];
    existing.push({ item, itemStr: JSON.stringify(item), platforms, platformStr: platforms.join(" || ") });
    tmpMap.set(uniqueKey, existing);
  }
  for (const item of items) {
    const newItem = item;
    const uniqueKey = item[uniqueKeyName];
    if (!uniqueKey) {
      continue;
    }
    if (!tmpMap.has(uniqueKey)) {
      tmpMap.set(uniqueKey, [{
        item: newItem,
        itemStr: JSON.stringify(newItem),
        platforms: [currentPlatform],
        platformStr: currentPlatform
      }]);
      continue;
    }
    const existing = tmpMap.get(uniqueKey);
    const newItemStr = JSON.stringify(newItem);
    const equalObj = existing.find((val) => val.itemStr === newItemStr);
    if (equalObj) {
      equalObj.platforms.push(currentPlatform);
      equalObj.platforms.sort();
      equalObj.platformStr = equalObj.platforms.join(" || ");
    } else {
      existing.push({
        item: newItem,
        itemStr: newItemStr,
        platforms: [currentPlatform],
        platformStr: currentPlatform
      });
    }
  }
  const result = new CommentArray();
  const platformUsage = {};
  tmpMap.forEach((val) => {
    Object.values(val).forEach((v) => {
      platformUsage[v.platformStr] = (platformUsage[v.platformStr] || 0) + 1;
    });
  });
  const usageKeys = Object.keys(platformUsage);
  const defaultPlatformStr = usageKeys.length ? usageKeys.reduce((a, b) => platformUsage[a] > platformUsage[b] ? a : b) : currentPlatform;
  result[Symbol.for("before:0")] = [{
    type: "LineComment",
    value: ` GENERATED BY UNI-PAGES, PLATFORM: ${defaultPlatformStr}`,
    inline: false,
    loc: {
      start: { line: 0, column: 0 },
      end: { line: 0, column: 0 }
    }
  }];
  for (const [_, list] of tmpMap) {
    for (const { item, platformStr } of list) {
      result.push(item);
      if (platformStr !== defaultPlatformStr) {
        result[Symbol.for(`before:${result.length - 1}`)] = [{
          type: "LineComment",
          value: ` #ifdef ${platformStr}`,
          inline: false,
          loc: {
            start: { line: 0, column: 0 },
            end: { line: 0, column: 0 }
          }
        }];
        result[Symbol.for(`after:${result.length - 1}`)] = [{
          type: "LineComment",
          value: " #endif",
          inline: false,
          loc: {
            start: { line: 0, column: 0 },
            end: { line: 0, column: 0 }
          }
        }];
      }
    }
  }
  return result;
}

function defineUniPages(config) {
  return config;
}

function VitePluginUniPages(userOptions = {}) {
  let ctx;
  const resolvedPagesJSONPath = path.join(
    process.env.VITE_ROOT_DIR || process.cwd(),
    userOptions.outDir ?? "src",
    OUTPUT_NAME
  );
  checkPagesJsonFileSync(resolvedPagesJSONPath);
  return {
    name: "vite-plugin-uni-pages",
    enforce: "pre",
    async configResolved(config) {
      ctx = new PageContext(userOptions, config.root);
      if (config.plugins.some((v) => v.name === "vite-plugin-uni-platform"))
        ctx.withUniPlatform = true;
      const logger = createLogger(void 0, {
        prefix: "[vite-plugin-uni-pages]"
      });
      ctx.setLogger(logger);
      await ctx.updatePagesJSON();
      if (config.command === "build") {
        if (config.build.watch)
          ctx.setupWatcher(chokidar.watch([...ctx.options.dirs, ...ctx.options.subPackages]));
      }
    },
    // Applet do not support custom route block, so we need to remove the route block here
    async transform(code, id) {
      if (!FILE_EXTENSIONS.find((ext) => id.endsWith(ext))) {
        return null;
      }
      const sfc = parseSFC(code, { filename: id });
      let macro;
      if (sfc.scriptSetup) {
        const ast = babelParse(sfc.scriptSetup.content, sfc.scriptSetup.lang || "js");
        macro = findMacro(ast.body, sfc.filename);
      }
      if (!macro && sfc.script) {
        const ast = babelParse(sfc.script.content, sfc.script.lang || "js");
        macro = findMacro(ast.body, sfc.filename);
      }
      const routeBlock = sfc.customBlocks.find((block) => block.type === "route");
      if (!macro && !routeBlock)
        return null;
      if (macro && routeBlock)
        throw new Error(`\u4E0D\u652F\u6301\u6DF7\u5408\u4F7F\u7528 definePage() \u548C <route/> ${id}`);
      const s = new MagicString(code);
      if (macro)
        s.remove(macro.start, macro.end);
      if (routeBlock) {
        console.log(lightYellow("\u8B66\u544A\uFF1A"), `${bold("<route/>")} \u6807\u7B7E\u5DF2\u5E9F\u5F03\uFF0C\u5C06\u5728\u4E0B\u4E00\u4E2A\u7248\u672C\u4E2D\u79FB\u9664\uFF0C\u8BF7\u4F7F\u7528 definePage() \u4EE3\u66FF\uFF1B${link("\u67E5\u770B\u8FC1\u79FB\u6307\u5357", "https://uni-helper.js.org/vite-plugin-uni-pages/definePage")}\u3002`);
        console.log(dim(id));
        console.log();
        const routeBlockMatches = s.original.matchAll(
          /<route[^>]*>([\s\S]*?)<\/route>/g
        );
        for (const match of routeBlockMatches) {
          const index = match.index;
          const length = match[0].length;
          s.remove(index, index + length);
        }
      }
      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: s.generateMap({
            source: id,
            includeContent: true,
            file: `${id}.map`
          })
        };
      }
    },
    configureServer(server) {
      ctx.setupViteServer(server);
    },
    resolveId(id) {
      if (id === MODULE_ID_VIRTUAL)
        return RESOLVED_MODULE_ID_VIRTUAL;
    },
    load(id) {
      if (id === RESOLVED_MODULE_ID_VIRTUAL)
        return ctx.virtualModule();
    }
  };
}

export { FILE_EXTENSIONS, MODULE_ID_VIRTUAL, OUTPUT_NAME, Page, PageContext, RESOLVED_MODULE_ID_VIRTUAL, VitePluginUniPages, babelGenerate, checkPagesJsonFileSync, debug, VitePluginUniPages as default, defineUniPages, extsToGlob, findImports, findMacro, getPageFiles, getRouteBlock, getRouteSfcBlock, invalidatePagesModule, isTargetFile, mergePageMetaDataArray, parseCode, parseCustomBlock, parseSFC, resolveOptions, resolvePageDirs, sleep, tryPageMetaFromCustomBlock, tryPageMetaFromMacro, writeFileWithLock };
